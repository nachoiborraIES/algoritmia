{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Algoritmia","text":"<p>Esta web abarca varios contenidos relacionados con la algoritmia. Desde la explicaci\u00f3n de qu\u00e9 es un algoritmo y los recursos con los que trabajaremos hasta el uso de algoritmos avanzados, pasando por diferentes niveles de complejidad. </p> <p>El uso de estos materiales est\u00e1 sujeto a una licencia Creative Commons CC BY-NC.</p>"},{"location":"01a.html","title":"\u00bfQu\u00e9 es un algoritmo?","text":"<p>La algoritmia es la ciencia que estudia los algoritmos. \u00bfY qu\u00e9 es un algoritmo? Pues un conjunto de instrucciones o pasos a seguir, ordenado y finito, que permite resolver un problema o realizar una actividad. Se parte de un estado inicial y unos datos de entrada para, con ellos, y siguiendo los pasos marcados, llegar a un estado final y un resultado esperado.</p> <p>El concepto de algoritmo es ligeramente diferente al concepto de programa ya que, por una parte, un programa puede estar formado por varios algoritmos. Por ejemplo, una hoja de c\u00e1lculo dispone de algoritmos para aplicar f\u00f3rmulas, ordenar tablas, etc. Por otra parte, un programa no tiene por qu\u00e9 terminar en un tiempo finito, como s\u00ed ocurre con un algoritmo.</p> <p>El concepto de algoritmo no es s\u00f3lo aplicable al \u00e1mbito de la inform\u00e1tica. En la vida cotidiana empleamos algoritmos para muchas otras cosas, como por ejemplo los pasos a seguir para una receta de cocina, o para calcular la divisi\u00f3n de dos n\u00fameros manualmente. En esta web nos centraremos en algoritmos aplicables en un ordenador, para lo que deben cumplir una serie de requisitos: </p> <ul> <li>Las acciones o pasos a seguir deben estar bien definidos y no ser ambiguos </li> <li>Debe haber una secuencia finita y ordenada de pasos </li> <li>El proceso debe acabar en un tiempo finito y delimitado. </li> </ul>"},{"location":"01b.html","title":"Lenguajes en 10 minutos","text":"<p>Para poder resolver un algoritmo es necesario utilizar un lenguaje de programaci\u00f3n, y escribir el c\u00f3digo con dicho lenguaje. En esta p\u00e1gina vamos a dar unas nociones b\u00e1sicas de c\u00f3mo arrancar con dos o tres lenguajes habituales, de modo que, en los siguientes documentos, los vayamos poniendo en pr\u00e1ctica para resolver distintos retos o problemas.</p>"},{"location":"01b.html#1-c-en-10-minutos","title":"1. C# en 10 minutos","text":"<p>Comenzaremos dando un vistazo r\u00e1pido a los fundamentos de la programaci\u00f3n b\u00e1sica con C#, para entender las estructuras b\u00e1sicas con las que empezar a hacer programas.</p>"},{"location":"01b.html#11-ejemplo-introductorio","title":"1.1. Ejemplo introductorio","text":"<p>Para verlo todo r\u00e1pidamente de un vistazo, observemos este ejemplo: en \u00e9l le pedimos al usuario que indique el n\u00famero de perros y gatos que hay en una protectora, y muestra por pantalla el porcentaje de perros y de gatos que hay.</p> <pre><code>using System;\n\nclass Ejemplo\n{\n    static void Main()\n    {\n        int perros, gatos, total, porcentajePerros, porcentajeGatos;\n\n        Console.WriteLine(\"Indica el n\u00famero de perros:\");\n        perros = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"Indica el n\u00famero de gatos:\");\n        gatos = Convert.ToInt32(Console.ReadLine());\n\n        total = perros + gatos;\n        porcentajePerros = perros * 100 / total;\n        porcentajeGatos = gatos * 100 / total;\n\n        Console.WriteLine(\"Hay un \" + porcentajePerros + \"% de perros\");\n        Console.WriteLine(\"Hay un \" + porcentajeGatos + \"% de gatos\");\n    }\n}\n</code></pre> <p>Analicemos las estructuras empleadas en el ejemplo:</p> <ul> <li>La instrucci\u00f3n <code>using System</code> del inicio se utiliza para incorporar el espacio de nombres System. Esto nos va a permitir utilizar directamente instrucciones que pertenecen a ese espacio de nombres, como por ejemplo Console.WriteLine, Convert.ToInt32 o Console.ReadLine. Si no incluy\u00e9ramos esta l\u00ednea tendr\u00edamos que anteponer el prefijo System delante de cada una de estas instrucciones (System.Console.WriteLine, System.Convert.ToInt32...) haciendo el c\u00f3digo m\u00e1s largo.</li> <li>Todo programa en C# debe estar encapsulado dentro de una clase <code>class</code> seguida de un nombre (en nuestro caso hemos llamado a la clase Ejemplo).</li> <li>Dentro de la clase debe haber un bloque de c\u00f3digo principal llamado <code>Main</code>, que es el que se ejecuta al lanzar el programa. En el caso de C#, el bloque Main se define como <code>static void Main()</code>.</li> <li>Entre las llaves del bloque Main definimos la secuencia de instrucciones que queremos que se ejecuten:</li> <li>Primero declaramos las variables que vamos a usar: emplearemos las variables <code>perros</code> y <code>gatos</code> para guardar el total de perros y gatos por separado que diga el usuario, la variable <code>total</code> para sumar ambas cantidades y las variables <code>porcentajePerros</code> y <code>porcentajeGatos</code> para calcular los porcentajes</li> <li>Despu\u00e9s le pedimos al usuario con dos mensajes <code>Console.WriteLine</code> que escriba la cantidad de perros y de gatos. Recogemos lo que escribe el usuario con la instrucci\u00f3n <code>Console.ReadLine</code> y lo tenemos que convertir a un dato num\u00e9rico entero con la instrucci\u00f3n <code>Convert.ToInt32</code>.</li> <li>Tras este bloque hacemos las operaciones matem\u00e1ticas: calculamos el <code>total</code> de animales de la protectora sumando perros y gatos, y los respectivos porcentajes de perros y gatos. Es IMPORTANTE recalcar que, a la hora de calcular los porcentajes, primero conviene multiplicar el dato por 100 y luego dividir entre el total porque, si lo hacemos al rev\u00e9s (primero dividir y luego multiplicar) la divisi\u00f3n dar\u00e1 0 al ser entera, y el porcentaje siempre saldr\u00e1 0.</li> <li>Finalmente mostramos por pantalla los datos de porcentajes calculados</li> </ul>"},{"location":"01b.html#12-software-para-programar","title":"1.2. Software para programar","text":"<p>\u00bfQu\u00e9 software necesitamos para programar en C#? Ofreceremos aqu\u00ed dos alternativas.</p>"},{"location":"01b.html#121-compilador-online","title":"1.2.1. Compilador online","text":"<p>Podemos utilizar un compilador online si queremos hacer pruebas r\u00e1pidas y sencillas, sin necesidad de tener nada instalado en el sistema. Aqu\u00ed indicamos un par de herramientas que os pueden venir bien:</p> <ul> <li>Editor online de Programiz para C#</li> <li>Editor online de TutorialsPoint para C#</li> </ul> <p>En cualquiera de estas opciones podemos editar nuestro c\u00f3digo en una ventana de edici\u00f3n y luego ejecutarlo en un terminal adjunto a la derecha, con el que podemos interactuar e introducir datos por teclado.</p>"},{"location":"01b.html#122-compilacion-y-ejecucion-local","title":"1.2.2. Compilaci\u00f3n y ejecuci\u00f3n local","text":"<p>Si queremos compilar y ejecutar programas en C# de forma local, tambi\u00e9n tenemos varias alternativas:</p> <ul> <li>En Windows ya disponemos de un compilador de C# integrado, en nuestra carpeta C:\\Windows\\Microsoft.NET\\Framework, seguido de una carpeta con n\u00famero de versi\u00f3n. Puede haber varias, y la m\u00e1s habitual es la versi\u00f3n 4.0.x.</li> <li>En Linux y Mac debemos instalar un compilador de C#, como el que tenemos disponible en el Proyecto Mono. Nos descargamos el instalador adecuado para nuestro sistema operativo y lo instalamos.</li> </ul> <p>Como editor simple para hacer nuestros programas podemos usar Geany, que se puede descargar desde su web oficial. Una vez lo tengamos instalado debemos seguir estos pasos:</p> <ol> <li>Crear un archivo nuevo y guardarlo como un programa C#. Por ejemplo, podemos copiar el c\u00f3digo del ejemplo anterior y guardarlo como Ejemplo.cs.</li> <li>Ahora vamos al men\u00fa Construir, y elegimos Establecer comandos de construcci\u00f3n. Debemos rellenar las casillas de Compilar y Ejecutar para que localicen c\u00f3mo compilar y ejecutar programas en C#. En el caso de Windows nos puede quedar m\u00e1s o menos as\u00ed (variando el nombre de la carpeta 4.0.x.x.x.x al compilar con la que tengas en tu instalaci\u00f3n de Windows). </li> </ol> <ol> <li>En el caso de Linux o Mac, donde habremos instalado el proyecto Mono, estas secciones normalmente se quedan rellenas con la configuraci\u00f3n adecuada para usar el compilador instalado.</li> <li>Para compilar nuestros programas podemos ir al men\u00fa Construir &gt; Compilar, y una vez compilado ejecutamos con Construir &gt; Ejecutar. Tambi\u00e9n podemos usar los botones correspondientes de la barra de herramientas superior.</li> </ol> <p>Ejercicio 1</p> <p>Prueba a compilar y ejecutar el ejemplo anterior de los perros y gatos, y comprueba el resultado que se muestra por pantalla al indicar 30 perros y 20 gatos.</p> <p>Ejercicio 2</p> <p>Ahora nuestra protectora a\u00f1ade un tercer tipo de animal: los p\u00e1jaros. Pide al usuario este nuevo dato y calcula ahora los tres porcentajes.</p> <p>Ejercicio 3</p> <p>Escribe un programa que le pida al usuario la nota de 3 ex\u00e1menes y calcule por pantalla su media (entera).</p>"},{"location":"01b.html#2-java-en-10-minutos","title":"2. Java en 10 minutos","text":"<p>Vamos ahora a dar unas r\u00e1pidas pinceladas para empezar a trabajar con Java y comprender los elementos m\u00e1s b\u00e1sicos del lenguaje.</p>"},{"location":"01b.html#21-ejemplo-introductorio","title":"2.1. Ejemplo introductorio","text":"<p>Para verlo todo de un vistazo usaremos el mismo ejemplo que hemos antes con C#: en este programa le pedimos al usuario que indique el n\u00famero de perros y gatos que hay en una protectora, y mostramos por pantalla el porcentaje de perros y de gatos que hay.</p> <pre><code>import java.util.Scanner;\n\npublic class Ejemplo\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int perros, gatos, total, porcentajePerros, porcentajeGatos;\n\n        System.out.println(\"Indica el n\u00famero de perros:\");\n        perros = sc.nextInt();\n        System.out.println(\"Indica el n\u00famero de gatos:\");\n        gatos = sc.nextInt();\n\n        total = perros + gatos;\n        porcentajePerros = perros * 100 / total;\n        porcentajeGatos = gatos * 100 / total;\n\n        System.out.println(\"Hay un \" + porcentajePerros + \"% de perros\");\n        System.out.println(\"Hay un \" + porcentajeGatos + \"% de gatos\");\n    }\n}\n</code></pre> <p>Analicemos las estructuras empleadas en el ejemplo, que guardan muchos parecidos con lo que hemos visto para C# en documentos anteriores:</p> <ul> <li>La instrucci\u00f3n <code>import java.util.Scanner</code> nos va a permitir utilizar en nuestro c\u00f3digo el objeto de tipo <code>Scanner</code>, que se emplea en Java para leer datos que se introducen desde el teclado.</li> <li>Todo programa en Java, al igual que ocurre en C#, debe estar encapsulado dentro de una clase <code>class</code> seguida de un nombre (en nuestro caso hemos llamado a la clase Ejemplo). Esta clase en Java se exige que sea <code>public</code> si dispone de un programa principal o <code>main</code>. Adem\u00e1s, el fichero fuente donde la guardemos se debe llamar igual que la clase (Ejemplo.java en nuestro caso).</li> <li>Dentro de la clase debe haber un bloque de c\u00f3digo principal llamado <code>main</code>, que es el que se ejecuta al lanzar el programa. En el caso de Java el bloque se define como <code>public static void main(String[] args)</code>.</li> <li>Entre las llaves del bloque main definimos la secuencia de instrucciones que queremos que se ejecuten:</li> <li>En primer lugar declaramos una variable de tipo <code>Scanner</code> para recoger los datos de teclado. Para ello, al crearla le indicamos que tome los datos de <code>System.in</code>, que es la entrada est\u00e1ndar de datos del sistema (es decir, el teclado).</li> <li>Tambi\u00e9n declaramos las variables que vamos a usar: emplearemos las variables <code>perros</code> y <code>gatos</code> para guardar el total de perros y gatos por separado que diga el usuario, la variable <code>total</code> para sumar ambas cantidades y las variables <code>porcentajePerros</code> y <code>porcentajeGatos</code> para calcular los porcentajes</li> <li>Despu\u00e9s le pedimos al usuario con dos mensajes <code>System.out.println</code> que escriba la cantidad de perros y de gatos. Recogemos lo que escribe el usuario con la instrucci\u00f3n <code>sc.nextInt</code> que permite leer n\u00fameros enteros del teclado, y los guardamos en las variables correspondientes para perros y gatos.</li> <li>Tras este bloque hacemos las operaciones matem\u00e1ticas: calculamos el <code>total</code> de animales de la protectora sumando perros y gatos, y los respectivos porcentajes de perros y gatos. Es IMPORTANTE recalcar que, a la hora de calcular los porcentajes, primero conviene multiplicar el dato por 100 y luego dividir entre el total porque, si lo hacemos al rev\u00e9s (primero dividir y luego multiplicar) la divisi\u00f3n dar\u00e1 0 al ser entera, y el porcentaje siempre saldr\u00e1 0.</li> <li>Finalmente mostramos por pantalla los datos de porcentajes calculados</li> </ul>"},{"location":"01b.html#22-software-para-programar","title":"2.2. Software para programar","text":"<p>\u00bfQu\u00e9 software necesitamos para programar en Java? Ofreceremos aqu\u00ed dos alternativas.</p>"},{"location":"01b.html#221-compilador-online","title":"2.2.1. Compilador online","text":"<p>Podemos utilizar un compilador online si queremos hacer pruebas r\u00e1pidas y sencillas, sin necesidad de tener nada instalado en el sistema. Aqu\u00ed indicamos un par de herramientas que os pueden venir bien:</p> <ul> <li>Editor online de Programiz para Java</li> <li>Editor online de TutorialsPoint para Java</li> </ul> <p>En cualquiera de estas opciones podemos editar nuestro c\u00f3digo en una ventana de edici\u00f3n y luego ejecutarlo en un terminal adjunto a la derecha, con el que podemos interactuar e introducir datos por teclado.</p>"},{"location":"01b.html#222-compilacion-y-ejecucion-local","title":"2.2.2. Compilaci\u00f3n y ejecuci\u00f3n local","text":"<p>Si queremos compilar y ejecutar programas en Java de forma local, debemos instalar el compilador y ejecutor, paquete conocido como JDK (Java Development Kit, kit de desarrollo Java). Podemos descargar la versi\u00f3n que prefiramos de esta web y descomprimirla en la carpeta que queramos. Por ejemplo, dentro de C:\\openjdk en Windows, o dentro de /home/usuario/openjdk en Linux o Mac (donde usuario ser\u00e1 el nombre de nuestro usuario en el sistema).</p> <p>Despu\u00e9s debemos configurar la variable PATH del sistema para que incluya la subcarpeta bin dentro de la carpeta de instalaci\u00f3n. En esta subcarpeta se encuentran los comandos <code>javac</code> y <code>java</code>, que nos permitir\u00e1n compilar y ejecutar nuestros programas, respectivamente.</p> <p>En el caso de Windows podr\u00eda quedar algo as\u00ed:</p> <p>En el caso de Linux escribiremos estos comandos desde un terminal:</p> <pre><code>echo \"export PATH=$PATH:/home/usuario/openjdk/bin\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <p>En el caso de Mac tambi\u00e9n escribimos estos comandos desde terminal, similares a los anteriores (aunque algo diferentes):</p> <pre><code>echo \"export PATH=$PATH:/home/usuario/openjdk/Contents/Home/bin\" &gt;&gt; ~/.bash_profile\nsource ~/.bash_profile\n</code></pre> <p>Tambi\u00e9n puede ser necesario configurar una nueva variable de entorno llamada JAVA_HOME que indique en qu\u00e9 carpeta hemos descomprimido o instalado JDK. Aqu\u00ed lo vemos para el caso de Windows:</p> <p>Aqu\u00ed tenemos los comandos correspondientes para Linux:</p> <pre><code>echo \"export JAVA_HOME=/home/usuario/openjdk\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <p>Y estos comandos ser\u00edan para Mac:</p> <pre><code>echo \"export JAVA_HOME=/home/usuario/openjdk/Contents/Home\" &gt;&gt; ~/.bash_profile\nsource ~/.bash_profile\n</code></pre> <p>Como editor simple para hacer nuestros programas podemos usar Geany, que se puede descargar desde su web oficial. Una vez lo tengamos instalado debemos seguir estos pasos:</p> <ol> <li>Crear un archivo nuevo y guardarlo como un programa Java. Por ejemplo, podemos copiar el c\u00f3digo del ejemplo anterior y guardarlo como Ejemplo.java. Esto lo identificar\u00e1 como un archivo de tipo Java, y har\u00e1 que Geany le asocie el compilador por defecto.</li> <li>Para compilar nuestros programas podemos ir al men\u00fa Construir &gt; Compilar, y una vez compilado ejecutamos con Construir &gt; Ejecutar. Tambi\u00e9n podemos usar los botones correspondientes de la barra de herramientas superior.</li> </ol> <p>Ejercicio 4</p> <p>Prueba a compilar y ejecutar el ejemplo anterior de los perros y gatos, y comprueba el resultado que se muestra por pantalla al indicar 30 perros y 20 gatos.</p> <p>Ejercicio 5</p> <p>Ahora nuestra protectora a\u00f1ade un tercer tipo de animal: los p\u00e1jaros. Pide al usuario este nuevo dato y calcula ahora los tres porcentajes.</p> <p>Ejercicio 6</p> <p>Escribe un programa que le pida al usuario la nota de 3 ex\u00e1menes y calcule por pantalla su media (entera).</p> <p>Ejercicio 7</p> <p>Escribe un programa que le pida al usuario su nombre y su edad y muestre el mensaje Hola XXXX, tienes YYYY a\u00f1os. Observa los problemas que puedes tener para leer datos de tipo texto y entero por teclado en Java.</p>"},{"location":"01b.html#3-python-en-10-minutos","title":"3. Python en 10 minutos","text":"<p>Finalmente, analizaremos los elementos principales para hacer programas en lenguaje Python.</p>"},{"location":"01b.html#31-ejemplo-introductorio","title":"3.1. Ejemplo introductorio","text":"<p>Para verlo todo de un vistazo usaremos el mismo ejemplo que hemos visto en documentos anteriores: en este programa le pedimos al usuario que indique el n\u00famero de perros y gatos que hay en una protectora, y mostramos por pantalla el porcentaje de perros y de gatos que hay.</p> <pre><code>print(\"Indica el n\u00famero de perros:\")\nperros = int(input())\nprint(\"Indica el n\u00famero de gatos:\")\ngatos = int(input())\n\ntotal = perros + gatos;\nporcentajePerros = perros * 100 / total;\nporcentajeGatos = gatos * 100 / total;\n\nprint(\"Hay un\", porcentajePerros,\"% de perros\")\nprint(\"Hay un\", porcentajeGatos, \"% de gatos\")\n</code></pre> <p>Analicemos las estructuras empleadas en el ejemplo. Podemos ver que el c\u00f3digo es m\u00e1s corto que el realizado con los lenguajes anteriores...</p> <ul> <li>La instrucci\u00f3n <code>print</code> sirve para mostrar informaci\u00f3n por pantalla. La usamos para pedirle al usuario el n\u00famero de perros y gatos al principio, y para mostrar los resultados al final. Si queremos mostrar varias cosas enlazadas, podemos separarlas por comas dentro de la instrucci\u00f3n <code>print</code>.</li> <li>Para recoger datos por teclado usamos la instrucci\u00f3n <code>input</code>, que recoge todo el texto que el usuario escribe hasta que pulsa Intro. Ese dato luego hay que convertirlo a entero, usando la instrucci\u00f3n <code>int()</code>.</li> <li>Tras este bloque hacemos las operaciones matem\u00e1ticas: calculamos el <code>total</code> de animales de la protectora sumando perros y gatos, y los respectivos porcentajes de perros y gatos. En este caso hay una diferencia con otros lenguajes, ya que la operaci\u00f3n <code>/</code> calcula una divisi\u00f3n real (con decimales), y ya no es tan importante multiplicar por 100 antes de dividir para no perder el resultado. </li> <li>Finalmente mostramos por pantalla los datos de porcentajes calculados</li> </ul>"},{"location":"01b.html#32-software-para-programar","title":"3.2. Software para programar","text":"<p>\u00bfQu\u00e9 software necesitamos para programar en Python? Ofreceremos aqu\u00ed dos alternativas.</p>"},{"location":"01b.html#321-interprete-online","title":"3.2.1. Int\u00e9rprete online","text":"<p>Podemos utilizar un int\u00e9rprete online si queremos hacer pruebas r\u00e1pidas y sencillas, sin necesidad de tener nada instalado en el sistema. Aqu\u00ed indicamos un par de herramientas que os pueden venir bien:</p> <ul> <li>Editor online de Programiz para Python</li> <li>Editor online de TutorialsPoint para Python</li> </ul> <p>En cualquiera de estas opciones podemos editar nuestro c\u00f3digo en una ventana de edici\u00f3n y luego ejecutarlo en un terminal adjunto a la derecha, con el que podemos interactuar e introducir datos por teclado.</p>"},{"location":"01b.html#322-ejecucion-local","title":"3.2.2. Ejecuci\u00f3n local","text":"<p>Si queremos ejecutar programas en Python de forma local, debemos instalar Python en nuestro sistema. Lo podemos descargar de su web oficial. En el caso de Windows convendr\u00e1 a\u00f1adir a la variable PATH la carpeta de instalaci\u00f3n. Esto puede hacerse marcando la casilla adecuada durante el proceso de instalaci\u00f3n:</p> <p>En el caso de Linux podemos comprobar si ya lo tenemos instalado en nuestra distribuci\u00f3n:</p> <pre><code>python 3 --version\n</code></pre> <p>Si el comando no se reconoce, podemos instalar Python con este otro comando (en sistemas Ubuntu o similares):</p> <pre><code>sudo apt-get install python3\n</code></pre> <p>Como editor simple para hacer nuestros programas podemos usar Geany, que se puede descargar desde su web oficial. Una vez lo tengamos instalado debemos seguir estos pasos:</p> <ol> <li>Crear un archivo nuevo y guardarlo como un programa Python. Por ejemplo, podemos copiar el c\u00f3digo del ejemplo anterior y guardarlo como Ejemplo.py. Esto lo identificar\u00e1 como un archivo de tipo Python, y har\u00e1 que Geany le asocie el int\u00e9rprete por defecto.</li> <li>Para ejecutar nuestros programas podemos ir al men\u00fa Construir &gt; Ejecutar (Python es un lenguaje interpretado, no se compila). Tambi\u00e9n podemos usar los botones correspondientes de la barra de herramientas superior.</li> </ol> <p>Ejercicio 8</p> <p>Prueba a compilar y ejecutar el ejemplo anterior de los perros y gatos, y comprueba el resultado que se muestra por pantalla al indicar 30 perros y 20 gatos.</p> <p>Ejercicio 9</p> <p>Ahora nuestra protectora a\u00f1ade un tercer tipo de animal: los p\u00e1jaros. Pide al usuario este nuevo dato y calcula ahora los tres porcentajes.</p> <p>Ejercicio 10</p> <p>Escribe un programa que le pida al usuario la nota de 3 ex\u00e1menes y calcule por pantalla su media (entera).</p>"},{"location":"01c.html","title":"Recursos para aprender","text":"<p>En esta secci\u00f3n vamos a echar un vistazo a una serie de recursos externos que utilizaremos para reforzar los conceptos que veremos y practicar con distintos problemas pr\u00e1cticos.</p>"},{"location":"01c.html#1-acepta-el-reto","title":"1. Acepta el Reto","text":"<p>Acepta el Reto es una fant\u00e1stica web recopilatoria de problemas o retos de programaci\u00f3n, elaborada por los compa\u00f1eros de la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid. Podemos registrarnos de forma gratuita, y acceder a todo el cat\u00e1logo de retos que ofrece. Aqu\u00ed tenemos la web oficial.</p> <p>La principal \"desventaja\" que ofrece esta web es que s\u00f3lo admite que programemos en los lenguajes C, C++ o Java. Pero, por lo dem\u00e1s, es un excelente repositorio para poner a prueba nuestras capacidades, aunque si queremos utilizar otros lenguajes s\u00f3lo podamos probar los problemas localmente, sin subirlos a la plataforma.</p> <p>Podemos consultar los retos agrupados por categor\u00edas para practicar un concepto en concreto (por ejemplo, el uso de bucles simples). En el men\u00fa superior vamos al apartado Problemas y elegimos la opci\u00f3n Por categor\u00edas. Eligiendo una categor\u00eda (por ejemplo, Construcciones de programaci\u00f3n) podemos ir navegando por sus subcategor\u00edas hasta encontrar la que nos interese:</p> <p>Una vez elegida la subcategor\u00eda aparecen los retos relacionados con ella. En cada reto veremos una barra de color a la derecha que indica cu\u00e1ntos usuarios han podido resolverlo del total que lo han intentado. Cuanto m\u00e1s grande sea la barra, m\u00e1s asequible es ese reto.</p>"},{"location":"01c.html#2-codewars","title":"2. CodeWars","text":"<p>CodeWars es otra web recopilatoria de problemas de programaci\u00f3n con una gran cantidad de retos en ingl\u00e9s. Los agrupa por distintos niveles de dificultad que mide en etapas kyu, simulando un dojo de artes marciales. Los retos de nivel m\u00e1s bajo son los que tienen mayor numeraci\u00f3n kyu, y a medida que la dificultad aumenta ascendemos de nivel kyu.</p> <p>En CodeWars podemos filtrar los retos que nos interesan por distintos criterios: nivel de dificultad, lenguaje de programaci\u00f3n en que queremos intentarlo, tem\u00e1tica (por ejemplo, retos sobre gesti\u00f3n de cadenas de texto), etc. Aqu\u00ed tenemos el enlace a la web oficial para registrarnos.</p> <p>En la secci\u00f3n izquierda hay un men\u00fa llamado Practice que abre un formulario para filtrar por distintos criterios. Por ejemplo, si queremos practicar con retos sencillos (nivel 8kyu) relacionado con uso de textos (Strings), para lenguaje Python, podr\u00edamos dejar algo as\u00ed:</p>"},{"location":"01c.html#3-kattis","title":"3. Kattis","text":"<p>Kattis es otra web recopilatoria de problemas de programaci\u00f3n multilenguaje, algo menos elaborada que CodeWars pero que permite generar retos de distintos tipos, subir los nuestros propios e incluso organizar competiciones. </p> <p>Tambi\u00e9n dispone de retos ordenados por nivel de dificultad, y la posibilidad de resolver un mismo reto en distintos lenguajes. Aqu\u00ed tenemos la web oficial para registrarnos y usar la plataforma.</p> <p>Desde el men\u00fa izquierdo Problems podemos buscar problemas que se ajusten a lo que queremos. En este caso podemos filtrar por el idioma en que est\u00e1n escritos con el desplegable Language (aunque la mayor\u00eda est\u00e1n en ingl\u00e9s) y tambi\u00e9n podemos ordenar el resultado por dificultad, creciente o decreciente:</p>"},{"location":"01c.html#4-uso-de-estos-recursos","title":"4. Uso de estos recursos","text":"<p>En las diferentes secciones de esta web propondremos ejemplos basados en retos de todas estas webs que hemos comentado. As\u00ed que conviene estar registrado en ellas para poderlos intentar y consolidar las cosas que vayamos aprendiendo. No te preocupes si a\u00fan no ves claro c\u00f3mo utilizar estas plataformas, lo aprenderemos en la secci\u00f3n de Algoritmos b\u00e1sicos.</p>"},{"location":"01d.html","title":"Probando Logo","text":"<p>Antes de entrar en materia sobre el desarrollo y prueba de algoritmos, en esta sesi\u00f3n vamos a dedicarnos a experimentar con una herramienta visual que nos puede dar una idea de a qu\u00e9 nos estamos refiriendo.</p>"},{"location":"01d.html#1-que-es-logo","title":"1. \u00bfQu\u00e9 es Logo?","text":"<p>Logo es un lenguaje de programaci\u00f3n educativo dise\u00f1ado en 1967, que se ide\u00f3 para ayudar a la gente a conocer las bases de la programaci\u00f3n a trav\u00e9s de instrucciones simples que producen un resultado directo en pantalla. Para ello cuenta con un entorno gr\u00e1fico donde una tortuga se mueve de acuerdo a las instrucciones que le facilitamos, dibujando figuras con su recorrido.</p>"},{"location":"01d.html#11-software-necesario","title":"1.1. Software necesario","text":"<p>Para poder trabajar con Logo hoy en d\u00eda contamos con distintas herramientas. Aqu\u00ed ponemos algunos ejemplos:</p> <ul> <li>WinLogo: una antigua aplicaci\u00f3n Windows que es a\u00fan compatible con versiones recientes. Podemos encontrarla como MSWLogo en diversas webs</li> <li>XLogo: una versi\u00f3n basada en Java que permite desarrollar programas logo en distintas plataformas. </li> <li>Int\u00e9rpretes online de Logo, como este de aqu\u00ed</li> </ul> <p>En estos apuntes utilizaremos esta \u00faltima opci\u00f3n para no tener que descargar ni instalar nada en nuestro sistema.</p> <p>En la parte inferior hay un cuadro donde escribiremos las instrucciones para mover a la tortuga por el \u00e1rea principal.</p>"},{"location":"01d.html#2-instrucciones-basicas-de-movimiento","title":"2. Instrucciones b\u00e1sicas de movimiento","text":"<p>Logo dispone de este conjunto de instrucciones b\u00e1sicas para mover la tortuga:</p> Abreviat.Instrucci\u00f3nDescripci\u00f3nEjemplo fd forward Avanza la tortuga el n\u00famero de pasos indicado fd 50 bk backward Retrocede la tortuga el n\u00famero de pasos indicado bk 20 rt right Gira a la derecha el n\u00famero de grados indicado rt 90 lt left Gira a la izquierda el n\u00famero de grados indicado lt 45 cs clearscreen Borra el lienzo de dibujo y resit\u00faa a la tortuga en el centro cs st showturtle Muestra la tortuga st ht hideturtle Oculta la tortuga ht pu penup Sube el l\u00e1piz (para no dibujar mientras se mueve la tortuga) pu pd pendown Baja el l\u00e1piz (para dibujar mientras se mueve la tortuga) pd setpos Coloca a la tortuga en las coordenadas que indiquemos (bas\u00e1ndonos en el centro del lienzo) setpos [50 10] <p>Podemos escribir m\u00e1s de una instrucci\u00f3n seguida en el recuadro inferior, separadas por espacios, y pulsando Intro se ejecutan todas en el orden indicado. Por ejemplo:</p> <pre><code>fd 40 rt 90 fd 50\n</code></pre> <p>Adem\u00e1s, podemos utilizar los cursores de flecha arriba/abajo para movernos por el historial de instrucciones escritas y volverlas a ejecutar si queremos.</p> <p>Ejercicio 1</p> <p>Utiliza las instrucciones anteriores para dibujar estas dos figuras. Puedes guardarte despu\u00e9s las instrucciones elegidas en ficheros de texto para tenerlas disponibles</p> <p> </p>"},{"location":"01d.html#3-colores-y-tamanos","title":"3. Colores y tama\u00f1os","text":"<p>Podemos tambi\u00e9n cambiar colores o grosor del trazo, y rellenar figuras siempre que est\u00e9n cerradas. Aqu\u00ed tenemos las instrucciones correspondientes:</p> Abreviat.Instrucci\u00f3nDescripci\u00f3nEjemplo setpc setpencolor Establece el color del trazo en formato RGB setpc [255 0 0] setpw setpenwidth Establece el grosor del trazo setpw 10 fill Rellena el \u00e1rea cerrada donde se encuentra actualmente la tortuga (debemos colocarla DENTRO de un \u00e1rea cerrada previamente) fill <p>Ejercicio 2</p> <p>Trata de crear este pent\u00e1gono con color azul. PISTA: si sumamos todos los \u00e1ngulos internos de un pent\u00e1gono, suman 540 grados.</p> <p> </p>"},{"location":"01d.html#4-repetir-instrucciones","title":"4. Repetir instrucciones","text":"<p>Habr\u00e1s comprobado con alg\u00fan ejercicio anterior que necesitas repetir varias instrucciones varias veces para conseguir la figura deseada. La pregunta que deber\u00edas hacerte es... \u00bfes necesaria esa repetici\u00f3n? Afortunadamente la respuesta es no.</p> <p>Logo dispone de la instrucci\u00f3n <code>repeat</code> que nos va a permitir repetir un conjunto de instrucciones un n\u00famero determinado de veces. Estas instrucciones a repetir las debemos poner entre corchetes tras la instruccion repeat en s\u00ed, como en este ejemplo que dibuja un cuadrado de lado 100:</p> <pre><code>repeat 4 [fd 100 rt 90]\n</code></pre> <p>Ejercicio 3</p> <p>Utilizando la instrucci\u00f3n repeat junto con otras que hemos visto anteriormente, trata de reproducir estas figuras:</p> <p> </p>"},{"location":"01d.html#5-utilizar-variables","title":"5. Utilizar variables","text":"<p>En Logo podemos emplear variables para guardar datos que queramos utilizar m\u00e1s adelante en el programa, o cuyo valor queramos modificar durante la ejecuci\u00f3n. Usamos la instrucci\u00f3n <code>make</code> para ello, indicando el nombre de la variable tras las comillas dobles:</p> <pre><code>make \"numero 10\n</code></pre> <p>Si queremos utilizar esa variable en nuestro c\u00f3digo pondremos el nombre precedido de dos puntos <code>:</code>, como en este ejemplo:</p> <pre><code>fd :numero\n</code></pre> <p>Tambi\u00e9n podemos reutilizar la instrucci\u00f3n make para modificar el valor previo de una variable:</p> <pre><code>make \"numero :numero + 10\n</code></pre> <p>Ejercicio 4</p> <p>Utilizando variables y bucles, trata de representar estas figuras:</p> <p> </p> <p>Ayuda</p> <p>Para dibujar un c\u00edrculo, podemos avanzar una peque\u00f1a cantidad y girar un peque\u00f1o n\u00famero de grados, y repetir esto un n\u00famero de veces, como aqu\u00ed: <code>repeat 120 [fd 1 rt 3]</code>. Si aumentamos el paso o reducimos el \u00e1ngulo obtenemos un c\u00edrculo m\u00e1s grande, y la operaci\u00f3n contraria (reducir el paso o aumentar el \u00e1ngulo) nos dar\u00e1 un c\u00edrculo m\u00e1s peque\u00f1o.</p>"},{"location":"01d.html#6-introduccion-a-las-funciones","title":"6. Introducci\u00f3n a las funciones","text":"<p>En el ejercicio anterior habr\u00e1s comprobado que necesitamos repetir un conjunto de instrucciones varias veces, cambiando el valor de una variable (por ejemplo, el \u00e1ngulo a girar). Tambi\u00e9n es posible \"ahorrarnos\" repetir estas estructuras en el c\u00f3digo englobando el conjunto de instrucciones en un m\u00f3dulo llamado normalmente funci\u00f3n. Simplemente le tenemos que dar un nombre a ese grupo de instrucciones y, cada vez que queramos ejecutarlo, invocamos ese nombre en el programa:</p> <pre><code>TO cuadrado\n   repeat 4 [fd 100 rt 90]\nEND\n</code></pre> <p>Si queremos dibujar un cuadrado en nuestro programa usando esta funci\u00f3n s\u00f3lo tenemos que hacer lo siguiente:</p> <pre><code>cuadrado\n</code></pre> <p>Adem\u00e1s, podemos facilitar a esta funci\u00f3n unas variables que utilizar:</p> <pre><code>TO cuadrado :tamano\n   repeat 4 [fd :tamano rt 90]\nEND\n</code></pre> <p>Esta funci\u00f3n va a dibujar un cuadrado del tama\u00f1o que indiquemos cuando invoquemos ese c\u00f3digo. Aqu\u00ed dibujamos cuadrados de distintos tama\u00f1os:</p> <pre><code>cuadrado 50\ncuadrado 100\ncuadrado 150\n</code></pre> <p>Obtendremos esta imagen como resultado:</p> <p>Ejercicio 5</p> <p>Trata de dibujar estas figuras empleando funciones:</p> <p> </p>"},{"location":"02a.html","title":"Introducci\u00f3n a los algoritmos b\u00e1sicos","text":"<p>En esta secci\u00f3n vamos a practicar con algunos algoritmos b\u00e1sicos. Estos algoritmos van a consistir principalmente en realizar una serie de operaciones matem\u00e1ticas sencillas o comprobaciones simples mediante alg\u00fan bucle y/o condici\u00f3n.</p> <p>Antes de comenzar con esta secci\u00f3n conviene que te hayas familiarizado con los conceptos explicados en la secci\u00f3n anterior. En concreto, se recomienda haber instalado y probado alguno de los lenguajes de programaci\u00f3n propuestos (o varios de ellos, a elegir entre C#, Java o Python), y tambi\u00e9n que te hayas registrado en las plataformas indicadas en la secci\u00f3n de Recursos para aprender.</p> <p>A partir de ah\u00ed, en esta secci\u00f3n de la web veremos:</p> <ul> <li>C\u00f3mo empezar a desenvolvernos en las distintas plataformas de recursos para aprender algoritmia</li> <li>Resoluci\u00f3n de retos de iniciaci\u00f3n en cada plataforma, en distintos lenguajes</li> <li>Planteamiento de distintos retos de dificultad sencilla a resolver en cada plataforma</li> </ul>"},{"location":"02b.html","title":"Nuestro primer reto: Hola mundo","text":"<p>Cuando aprendemos a programar en cualquier lenguaje de programaci\u00f3n, el primer c\u00f3digo que se suele aprender es uno que muestre un mensaje corto por pantalla, que t\u00edpicamente suele ser Hola mundo (Hello world en ingl\u00e9s).</p>"},{"location":"02b.html#1-descripcion-del-reto-a-resolver-en-acepta-el-reto","title":"1. Descripci\u00f3n del reto a resolver en Acepta el Reto","text":"<p>As\u00ed que, para empezar nuestra andadura en la resoluci\u00f3n de problemas algor\u00edtmicos, vamos a ver c\u00f3mo resolver un reto llamado Hola mundo, que tenemos disponible en este enlace de la plataforma Acepta el Reto.</p> <p>Lee con detenimiento el enunciado del reto. A modo de resumen, lo que nos pide es que hagamos un programa en el que leeremos un n\u00famero entero entre 0 y 5, y deberemos mostrar el mensaje Hola mundo. por pantalla tantas veces como el n\u00famero que hemos le\u00eddo. Por ejemplo, si leemos por pantalla el n\u00famero 4, la salida de nuestro programa deber\u00e1 ser esta:</p> <pre><code>Hola mundo.\nHola mundo.\nHola mundo.\nHola mundo.\n</code></pre> <p>Notar que en estos retos no tenemos que mostrar m\u00e1s informaci\u00f3n por pantalla que la que nos piden (es decir, no tenemos que pedirle al usuario \"Escribe el n\u00famero de veces que hay que repetir el mensaje\"). Adem\u00e1s, el texto de salida debe coincidir exactamente con el que nos dan de ejemplo. En este caso, debemos escribir la frase Hola mundo., incluyendo el punto del final.</p> <p>Dado que estamos en Acepta el reto, podemos resolver este problema usando los lenguajes Java o C++ (de entre los que estamos aprendiendo a usar en esta web). En el caso de Java, una posible soluci\u00f3n al problema ser\u00eda \u00e9sta:</p> <pre><code>import java.util.Scanner;\n\npublic class Reto116\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int veces;\n\n        veces = sc.nextInt();\n\n        for(int i = 1; i &lt;= veces; i++)\n        {\n            System.out.println(\"Hola mundo.\");\n        }\n    }\n}\n</code></pre> <p>A la hora de probar el programa, una vez nos hayamos logueado en la web, vamos a la p\u00e1gina del reto y en el men\u00fa izquierdo ver\u00e9is una opci\u00f3n que pone Enviar.</p> <p>Se abrir\u00e1 un formulario donde podemos elegir el lenguaje en el que queremos resolver el reto (C++ en nuestro caso) y o bien adjuntar el archivo con el c\u00f3digo fuente, o bien copiarlo y pegarlo en el formulario de c\u00f3digo inferior:</p> <p>Al pulsar el bot\u00f3n inferior de Enviar se env\u00eda el c\u00f3digo al servidor, y tardar\u00e1 unos segundos en procesarlo y emitir una respuesta. Algunos ejemplos de respuestas que podemos obtener son:</p> <ul> <li>AC: reto aceptado. Es el resultado que debemos esperar en todos los retos que resolvamos. El resto de mensajes corresponden a distintos tipos de error.</li> <li>WA: respuesta incorrecta (wrong answer). Este resultado significa que el reto no ha dado el resultado esperado en alguna de las pruebas que se han hecho</li> <li>RTE: error en tiempo de ejecuci\u00f3n (runtime exception). Se ha producido un error mientras se ejecutaba el c\u00f3digo del programa. Esta opci\u00f3n es frecuente que pase cuando estamos recorriendo datos de una colecci\u00f3n, por ejemplo.</li> <li>PE: error de presentaci\u00f3n (presentation error). El resultado es casi correcto, pero hay alguna cosa al inicio o al final de la respuesta que no concuerda. T\u00edpicamente nos pasar\u00e1 cuando pongamos alg\u00fan espacio en blanco de sobra al inicio o al final del texto a mostrar.</li> <li>TLE: tiempo l\u00edmite excedido (time limit exceeded). Esto se dar\u00e1 en retos donde la eficiencia y la rapidez son importantes, y nuestro programa tarde demasiado tiempo en resolverlos. Volveremos a ellos en la secci\u00f3n de Algoritmos intermedios.</li> </ul> <p>En nuestro caso, al enviar el c\u00f3digo tal y como lo tenemos en el ejemplo obtendremos una respuesta satisfactoria:</p> <p>En la secci\u00f3n izquierda, en el men\u00fa Mis env\u00edos podemos ver el historial de env\u00edos que hemos hecho para esta reto, y consultar el c\u00f3digo fuente que usamos en cada uno:</p>"},{"location":"02b.html#2-descripcion-del-reto-a-resolver-en-kattis","title":"2. Descripci\u00f3n del reto a resolver en Kattis","text":"<p>En la plataforma Kattis el reto m\u00e1s sencillo que podemos plantearnos es este reto de Hello world. Como se indica en la descripci\u00f3n, debemos hacer un programa que diga Hello world.</p> <p>Vamos a resolverlo en lenguaje Python. Para ello, en la secci\u00f3n derecha elegimos el lenguaje Python 3 y pulsamos en Start coding:</p> <p>En el editor de c\u00f3digo que se abre escribimos el c\u00f3digo para resolver el reto, que es tan sencillo como \u00e9ste:</p> <pre><code>print(\"Hello World!\")\n</code></pre> <p>Pulsando el bot\u00f3n de Submit en la parte inferior del formulario enviamos el reto para que se eval\u00fae:</p> <p>En la siguiente pantalla veremos los resultados:</p> <p>Lo deseable es ver el reto como aceptado (Accepted) con todas las aspas verdes marcadas. En el caso de haber tenido alg\u00fan error, podemos pulsar el bot\u00f3n superior de Edit and resubmit y volverlo a intentar. Notar que tambi\u00e9n podemos descargar el fichero con el c\u00f3digo fuente que hemos usado para resolver el reto.</p> <p>Ejercicio 1</p> <p>Trata de resolver este mismo reto en C# y prueba tu programa en la plataforma.</p>"},{"location":"02b.html#3-descripcion-del-reto-a-resolver-en-codewars","title":"3. Descripci\u00f3n del reto a resolver en CodeWars","text":"<p>En cuanto a la plataforma CodeWars, uno de los retos m\u00e1s sencillos que podemos resolver es este reto. Como podemos leer en la descripci\u00f3n, nos pide que hagamos una funci\u00f3n que devuelva el mensaje \"hello world!\". En el desplegable superior podemos elegir el lenguaje en que resolverlo (en nuestro caso elegiremos C#), y luego en la parte superior derecha tenemos un bot\u00f3n Train para escribir y probar nuestro c\u00f3digo:</p> <p>En el caso de CodeWars, los problemas se encapsulan en bloques de c\u00f3digo llamados funciones, sobre los que aprenderemos m\u00e1s adelante. De momento, en el formulario que aparecer\u00e1 debemos escribir un bloque de c\u00f3digo o funci\u00f3n llamado greet que devuelva (return) el texto indicado:</p> <p>En la parte inferior derecha tenemos un bot\u00f3n llamado Test para hacer una prueba preliminar de nuestro c\u00f3digo y ver si cumple con lo que se pide:</p> <p>Una vez pasadas las pruebas preliminares, podemos pulsar el segundo bot\u00f3n Attempt para pruebas m\u00e1s exhaustivas, y ver si las supera tambi\u00e9n.</p> <p>A medida que vayamos superando retos aumentar\u00e1 nuestra puntuaci\u00f3n y nivel, que podemos consultar en la parte superior derecha de la web:</p> <p>Ejercicio 2</p> <p>Trata de resolver este mismo reto en Python y prueba tu programa en la plataforma. Deber\u00e1s averiguar c\u00f3mo se definen funciones en Python, y crear una llamada <code>greet</code> que devuelva el texto indicado con una instrucci\u00f3n <code>return</code></p>"},{"location":"02c.html","title":"Algoritmos b\u00e1sicos con condiciones simples","text":"<p>En este documento vamos a practicar el uso de condiciones simples en diferentes tipos de problemas a resolver. Entendemos por condici\u00f3n simple a condiciones que sean f\u00e1cilmente programables, como por ejemplo comprobar si una variable (o unas pocas) valen exactamente un valor, o son mayores o menores que un valor determinado.</p>"},{"location":"02c.html#1-el-dia-de-navidad","title":"1. El d\u00eda de Navidad","text":"<p>El d\u00eda de Navidad es una fecha se\u00f1alada y f\u00e1cil de recordar: el 25 de diciembre. Si lo expresamos de forma num\u00e9rica, el d\u00eda es el 25 y el mes es el 12. Sabiendo esto, vamos a echar un vistazo a este reto de Acepta el Reto.</p> <p>El reto en s\u00ed consiste en que:</p> <ul> <li>Primero nos van a indicar cu\u00e1ntas fechas nos van a proporcionar (un n\u00famero N por concretar)</li> <li>Despu\u00e9s leeremos cada una de esas N fechas (primero el d\u00eda y luego el mes) y diremos SI si corresponde al d\u00eda de Navidad (25 del 12) o NO en caso contrario.</li> </ul> <p>Vamos a plantear el reto en Java: utilizaremos el m\u00e9todo <code>nextInt</code> de la variable <code>Scanner</code> para leer primero el n\u00famero de fechas, y luego el d\u00eda y mes de cada fecha (usamos un bucle <code>for</code> para leer tantas fechas como nos diga el n\u00famero que hemos le\u00eddo al principio). Cuando leamos cada d\u00eda y mes, comprobamos con un <code>if</code> si es el d\u00eda de Navidad o no.</p> <pre><code>import java.util.Scanner;\n\npublic class Reto362\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int numFechas, dia, mes;\n\n        // Leemos el n\u00famero de fechas que nos van a pasar\n        numFechas = sc.nextInt();\n\n        // Repetimos el bucle para leer ese n\u00famero de fechas\n        for(int i = 1; i &lt;= numFechas; i++)\n        {\n            // Leemos d\u00eda y mes por separado\n            dia = sc.nextInt();\n            mes = sc.nextInt();\n\n            // Comprobamos si es el d\u00eda de Navidad\n            if(dia == 25 &amp;&amp; mes == 12)\n            {\n                System.out.println(\"SI\");\n            }\n            else\n            {\n                System.out.println(\"NO\");\n            }\n        }\n    }\n}\n</code></pre> <p>Si pruebas a enviar el c\u00f3digo de este ejemplo, ver\u00e1s que lo da como aceptado.</p>"},{"location":"02c.html#2-ecos-impares","title":"2. Ecos impares","text":"<p>Vamos ahora a este reto de Kattis. En \u00e9l nos van a dar primero un n\u00famero, indicando cu\u00e1ntas palabras vamos a tener que leer. Despu\u00e9s leeremos cada una de esas palabras (una por l\u00ednea) y tenemos que sacar por pantalla s\u00f3lo las que nos den en posiciones impares. Por ejemplo, si nos dicen que vamos a leer 5 palabras con esta entrada:</p> <pre><code>5\nuna\ndos\ntres\ncuatro\ncinco\n</code></pre> <p>Nuestra salida por pantalla debe mostrar s\u00f3lo las que hemos le\u00eddo en posiciones impares, es decir:</p> <pre><code>una\ntres\ncinco\n</code></pre> <p>Leeremos primero el n\u00famero de palabras n y construiremos un bucle <code>for</code> que lea esas palabras. Dentro del bucle mostraremos \u00fanicamente las palabras que tengan el contador del bucle impar. Para ver si un n\u00famero es impar, tenemos que comprobar que NO sea divisible por 2.</p> <p>El c\u00f3digo puede quedar m\u00e1s o menos as\u00ed en C#:</p> <pre><code>using System;\n\nclass Ejemplo\n{\n    static void Main()\n    {\n        int numPalabras;\n        string palabra;\n\n        // Leemos el n\u00famero de palabras\n        numPalabras = Convert.ToInt32(Console.ReadLine());\n\n        // Recorremos las palabras y mostramos las impares\n        for(int i = 1; i &lt;= numPalabras; i++)\n        {\n            palabra = Console.ReadLine();\n            if(i % 2 != 0)\n            {\n                Console.WriteLine(palabra);\n            }\n        }\n    }\n}\n</code></pre> <p>Ejercicio 1</p> <p>Trata de resolver este mismo reto en Python y comprueba que la plataforma lo acepta.</p>"},{"location":"02c.html#3-contando-sables-laser","title":"3. Contando sables l\u00e1ser","text":"<p>Echemos un vistazo a este reto de CodeWars. En \u00e9l se nos pide que indiquemos cu\u00e1ntos sables l\u00e1ser tiene el usuario almacenado en la variable <code>name</code>, sabiendo que si se llama Zach tiene 18 sables, y el resto tienen 0.</p> <p>Podr\u00edamos resolverlo en Python de este modo:</p> <pre><code>def how_many_light_sabers_do_you_own(name=None):\n    result = 0\n    if name == \"Zach\":\n        result = 18\n    return result\n</code></pre> <p>El dato <code>name=None</code> es el dato que le proporcionamos al programa. Lo igualamos a None (\"nada\" en Python), porque el ejercicio dice que es posible que no proporcionemos ning\u00fan nombre y, en ese caso, tambi\u00e9n nos tiene que decir que hay 0 sables l\u00e1ser.</p> <p>Ejercicio 2</p> <p>Trata de resolver este mismo reto en C# y comprueba que la plataforma lo acepta. En el caso de C# no debemos igualar el par\u00e1metro <code>name</code> a nada. Simplemente ver si es \"Zach\" o es otra cosa.</p>"},{"location":"02c.html#4-mas-retos-para-practicar","title":"4. M\u00e1s retos para practicar","text":"<p>Agrupamos en este apartado otros retos de caracter\u00edsticas similares para practicar.</p>"},{"location":"02c.html#41-contando-en-la-arena","title":"4.1. Contando en la arena","text":"<p>En este reto de Acepta el Reto se plantea el siguiente problema: c\u00f3mo contar usando s\u00f3lo el n\u00famero uno. Como entrada nos ir\u00e1n dando n\u00fameros positivos, y para cada uno tendremos que indicar a qu\u00e9 equivale en unos. Por ejemplo, si leemos el n\u00famero 4 equivaldr\u00eda a 1111 (cuatro unos). El problema terminar\u00e1 cuando leamos un cero.</p> <p>Ejercicio 3</p> <p>Trata de resolver este reto en Java y comprueba el resultado en la plataforma</p>"},{"location":"02c.html#42-tomar-dos-piedras","title":"4.2. Tomar dos piedras","text":"<p>En este reto de Kattis se nos plantea un juego con piedras: hay N piedras en el suelo formando una fila o secuencia, numeradas de la piedra 1 a la N. Alice y Bob juegan por turnos, y deben tomar dos piedras consecutivas, hasta que ya no queden dos piedras consecutivas que tomar. Si el n\u00famero de piedras que queda al final es impar, gana Alice, y si es par, gana Bob. Empieza jugando Alice siempre.</p> <p>Como entrada nos dir\u00e1n el n\u00famero de piedras que hay, y debemos indicar, suponiendo que ambos jugadores juegan de forma inteligente, qui\u00e9n va a ganar. Veamos algunos ejemplos:</p> <ul> <li>Hay 1 piedra. Como no se pueden tomar dos consecutivas y queda un n\u00famero impar de piedras, gana Alice</li> <li>Hay 2 piedras. Alice toma las dos piedras y deja 0 piedras restantes (n\u00famero par), por lo que gana Bob.</li> <li>Hay 5 piedras. Si Alice toma cualquier secuencia de 2 piedras consecutivas, Bob elegir\u00e1 otra secuencia de 2 que tambi\u00e9n quedar\u00e1 disponible, y finalmente quedar\u00e1 una piedra suelta. Gana Alice.</li> </ul> <p>Ejercicio 4</p> <p>Trata de resolver este reto en Python y comprueba el resultado en la plataforma.</p>"},{"location":"02c.html#43-si-no-puedes-dormir-cuenta-ovejas","title":"4.3. Si no puedes dormir, cuenta ovejas","text":"<p>En este reto de CodeWars nos proponen contar ovejas para dormir. Dado el valor de una variable <code>n</code>, debemos construir un texto con todo el conteo de ovejas, en el formato que se indica en el ejercicio. Por ejemplo, si n = 3 el texto a mostrar (o devolver con return) debe ser 1 sheep...2 sheep...3 sheep....</p> <p>Ejercicio 5</p> <p>Trata de resolver este reto en C# y comprueba el resultado en la plataforma.</p>"},{"location":"02d.html","title":"Algoritmos matem\u00e1ticos simples","text":"<p>En este documento vamos a practicar con algoritmos en los que hay que realizar alguna operaci\u00f3n matem\u00e1tica sencilla, como alguna suma, divisi\u00f3n, c\u00e1lculo de resto... para poder resolver el problema en cuesti\u00f3n.</p>"},{"location":"02d.html#1-losetas-claras-y-oscuras","title":"1. Losetas claras y oscuras","text":"<p>En este reto de Acepta el Reto se nos plantea el problema de contar el n\u00famero de losetas necesarias para cubrir un suelo con un tama\u00f1o determinado. </p> <p>Comenzaremos el problema leyendo el n\u00famero de casos de prueba diferentes que tendremos que procesar, y luego, para cada caso de prueba, nos dar\u00e1n dos n\u00fameros: el n\u00famero de losetas que caben a lo ancho y el n\u00famero que caben a lo largo de la habitaci\u00f3n a cubrir.</p> <p>Para cada caso tendremos que indicar cu\u00e1ntas losetas claras y cu\u00e1ntas oscuras van a hacer falta, teniendo en cuenta que queremos que haya el mismo n\u00famero de ambas o, en el caso de que no sea posible, que haya una loseta m\u00e1s de las claras que de las oscuras.</p> <p>Por ejemplo, si la habitaci\u00f3n a cubrir mide 5 losetas de ancho y 4 de largo, necesitaremos un total de 20 losetas. Har\u00e1n falta entonces 10 losetas claras y 10 oscuras. En cambio, si la habitaci\u00f3n mide 5 losetas de ancho y 3 de largo, har\u00e1n falta 15 losetas, y en ese caso usaremos 8 claras y 7 oscuras.</p> <p>Lo primero que tendremos que hacer es leer el n\u00famero de casos de prueba, y con \u00e9l construir un bucle (for) para procesarlos todos. En cada caso de prueba leeremos el ancho y el alto de la habitaci\u00f3n (en n\u00famero de losetas), y con ello sabremos cu\u00e1ntas losetas har\u00e1n falta. Si es un n\u00famero par, dividimos por dos y tendremos las losetas claras y las oscuras. Si es impar, tendremos que sumar una loseta clara m\u00e1s a esa mitad.</p> <p>Aqu\u00ed tenemos c\u00f3mo resolver el ejercicio con Java:</p> <pre><code>import java.util.Scanner;\n\npublic class Reto413\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int casos, ancho, alto, totalBaldosas, claras, oscuras;\n\n        casos = sc.nextInt();\n\n        for(int i = 1; i &lt;= casos; i++)\n        {\n            // Leemos el ancho y el alto de cada caso de prueba\n            ancho = sc.nextInt();\n            alto = sc.nextInt();\n            // Calculamos el total de baldosas\n            totalBaldosas = ancho * alto;\n            // La mitad ser\u00e1n claras y la otra mitad oscuras\n            claras = totalBaldosas / 2;\n            oscuras = claras;\n            // Si el n\u00famero de baldosas es impar, habr\u00e1 una clara m\u00e1s\n            if(totalBaldosas % 2 != 0)\n            {\n                claras++;\n            }\n\n            System.out.println(claras + \" \" + oscuras);\n        }\n    }\n}\n</code></pre> <p>Aunque no ser\u00edan necesarias tantas, hemos declarado variables para cada cosa:</p> <ul> <li>La variable <code>casos</code> leer\u00e1 el n\u00famero de casos de prueba a procesar</li> <li>Las variables <code>ancho</code> y <code>largo</code> leer\u00e1n el ancho y largo de cada caso</li> <li>La variable <code>total</code> calcula el total de losetas necesarias (ancho x largo)</li> <li>En las variables <code>claras</code> y <code>oscuras</code> almacenamos el n\u00famero de losetas de cada tipo, para mostrarlo en la respuesta (en ese orden, separadas por un espacio).</li> </ul>"},{"location":"02d.html#2-para-tu-informacion","title":"2. Para tu informaci\u00f3n","text":"<p>En este reto de Kattis nos plantean c\u00f3mo detectar el prefijo de un n\u00famero telef\u00f3nico para saber a qu\u00e9 centralita tenemos que redirigir la llamada. En concreto, los n\u00fameros (todos ellos de 7 d\u00edgitos) que comiencen por 555 ser\u00e1n redirigidos a un operador de informaci\u00f3n, y el resto no.</p> <p>Debemos escribir un programa que lea un n\u00famero telef\u00f3nico (se asume y garantiza que ser\u00e1 de 7 d\u00edgitos) y muestre por pantalla un 1 si empieza por 555 (y hay que redirigirlo al operador de informaci\u00f3n) o 0 en caso contrario.</p> <p>Vamos a plantear el problema usando Python. Leeremos el n\u00famero entero y, para saber por qu\u00e9 3 d\u00edgitos empieza, lo que haremos ser\u00e1 dividir el n\u00famero entre 10000. Esto quitar\u00e1 los \u00faltimos 4 d\u00edgitos, y as\u00ed podremos comprobar cu\u00e1les son esos tres primeros. Si coincide con 555 sacaremos un 1 por pantalla, y si es otra cosa sacaremos un 0.</p> <p>El c\u00f3digo podr\u00eda quedar as\u00ed:</p> <pre><code>numero = int(input())\nprefijo = numero // 10000 # Divisi\u00f3n entera\n\nif prefijo == 555:\n    print(1)\nelse:\n    print(0)\n</code></pre> <p>Ejercicio 1</p> <p>Trata de resolver este mismo reto en C# y comprueba que la plataforma lo acepta.</p>"},{"location":"02d.html#3-anos-bisiestos","title":"3. A\u00f1os bisiestos","text":"<p>En este reto de CodeWars nos proponen averiguar si un a\u00f1o almacenado en una variable <code>year</code> es bisiesto o no. Las reglas que nos dicen son las siguientes:</p> <ul> <li>Si es divisible por 4, es bisiesto</li> <li>Si es divisible por 100, no es bisiesto</li> <li>Si es divisible por 400, s\u00ed es bisiesto</li> </ul> <p>Es decir, un a\u00f1o como por ejemplo 2024, divisible por 4, es bisiesto. El a\u00f1o 2100 es divisible por 4, pero tambi\u00e9n lo es por 100, y no lo es por 400, por lo que no es bisiesto. En cambio el a\u00f1o 2400, que es divisible por 400 s\u00ed lo es.</p> <p>El c\u00f3digo para resolver el ejercicio en C# podr\u00eda quedar as\u00ed:</p> <pre><code>public static class Kata\n{\n    public static bool IsLeapYear(int year)\n    {\n        bool result = false;\n        if(year % 4 == 0 &amp;&amp; year % 100 != 0)\n            result = true;\n        else if (year % 400 == 0)\n            result = true;\n        return result;\n    }\n}\n</code></pre>"},{"location":"02d.html#4-mas-retos-para-practicar","title":"4. M\u00e1s retos para practicar","text":"<p>Agrupamos en este apartado otros retos de caracter\u00edsticas similares para practicar.</p>"},{"location":"02d.html#41-tu-amigable-vecino","title":"4.1. Tu amigable vecino","text":"<p>En este reto de Acepta el Reto debemos determinar la distancia m\u00ednima que debe recorrer SpiderMan para desactivar dos bombas situadas en la Quinta Avenida de Nueva York.</p> <p>El problema comienza leyendo el n\u00famero de casos de prueba que tenemos que procesar. Despu\u00e9s, cada caso de prueba consta de 3 n\u00fameros (distancias en metros):</p> <ul> <li>Posici\u00f3n de Spiderman desde el inicio de la Quinta Avenida</li> <li>Posici\u00f3n de la primera bomba (tambi\u00e9n desde el inicio de la Quinta Avenida)</li> <li>Posici\u00f3n de la segunda bomba (tambi\u00e9n desde el inicio de la Quinta Avenida)</li> </ul> <p>Tendremos que mostrar por pantalla el total m\u00ednimo de metros que tendr\u00e1 que recorrer SpiderMan para desactivar las dos bombas.</p> <p>Por ejemplo: si SpiderMan se encuentra a distancia 100, una bomba a distancia 150 y otra a distancia 200, SpiderMan tendr\u00e1 que recorrer 50 metros para llegar a la primera bomba y, desde ah\u00ed, otros 50 metros para llegar a la segunda bomba: en total, 100 metros.</p> <p>En cambio, si SpiderMan est\u00e1 a distancia 300, una bomba a distancia 100 y otra a distancia 700, SpiderMan tendr\u00e1 que decidir qu\u00e9 bomba desactivar primero. Si elige la bomba 2, recorrer\u00e1 400 metros hasta ella (700 menos su posici\u00f3n inicial 300), y luego desde all\u00ed tiene otros 600 metros hasta la primera bomba. En total, 100 metros. En cambio, si elige ir primero a por la bomba uno recorre 300 - 100 = 200 metros, y luego los 600 que hay entre las dos bombas. En total, 800 metros. La distancia m\u00ednima en este caso ser\u00eda de 800 metros.</p> <p>Como PISTA para resolver este reto en Java, puedes usar la instrucci\u00f3n <code>Math.abs</code>, que calcula el valor absoluto de un valor. Si llamamos <code>s</code> a la posici\u00f3n de SpiderMan, <code>a</code> a la posici\u00f3n de la bomba A y <code>b</code> la posici\u00f3n de la bomba <code>b</code>, podemos usar esta funci\u00f3n para calcular la distancia de SpiderMan a cualquiera de las dos bombas. Por ejemplo:</p> <pre><code>// Distancia de SpiderMan a la bomba A\nint distA = Math.abs(s - a);\n</code></pre> <p>De este modo, da igual si la bomba est\u00e1 antes o despu\u00e9s de SpiderMan, la diferencia resultar\u00e1 un n\u00famero positivo. </p> <p>En definitiva, tendremos que decidir qu\u00e9 es mejor:</p> <ul> <li>Ir primero a por la bomba A y luego a por la B (sumar las dos distancias)</li> <li>Ir primero a por la bomba B y luego a por la A (sumar las dos distancias)</li> </ul> <p>Ejercicio 2</p> <p>Trata de resolver este reto en Java y comprueba que la plataforma lo acepta.</p>"},{"location":"02d.html#42-construyendo-piramides","title":"4.2. Construyendo pir\u00e1mides","text":"<p>En este reto de Kattis nos piden que calculemos cu\u00e1ntas alturas de una pir\u00e1mide podemos construir con un n\u00famero determinado de bloques.</p> <p>Para ello, hay que tener en cuenta que la primera altura (el pico superior) contiene un bloque. La siguiente altura contiene 9 bloques, es decir, 2 bloques m\u00e1s de ancho por cada lado (pasamos de 1x1 a 3x3). La siguiente altura tendr\u00e1 una malla de 5x5 bloques... y as\u00ed sucesivamente.</p> <p>Fuente: open.kattis.com</p> <p>As\u00ed, si tenemos, por ejemplo, 83 bloques, tendremos que tener en cuenta que:</p> <ul> <li>Gastaremos 1 bloque para el primer nivel</li> <li>Gastaremos 9 bloques para el segundo nivel (10 en total)</li> <li>Gastaremos 5x5 = 25 bloques para el tercer nivel (35 en total)</li> <li>Gastar\u00edamos 7 x 7 = 49 bloques para el cuarto nivel (84 en total), pero no tenemos suficientes. As\u00ed que nuestra respuesta en este caso ser\u00e1 que podemos hacer 3 alturas.</li> </ul> <p>Ejercicio 3</p> <p>Trata de resolver este reto en C# y comprueba que la plataforma lo acepta.</p>"},{"location":"02d.html#43-dos-veces-mayor","title":"4.3. Dos veces mayor","text":"<p>En este reto de CodeWars nos piden calcular cu\u00e1ntos a\u00f1os han pasado o pasar\u00e1n para que un padre tenga el doble de a\u00f1os que un hijo, dadas sus edades actuales.</p> <p>Hay que tener en cuenta que este hecho habr\u00e1 pasado ya, o pasar\u00e1, dependiendo de las edades. Por ejemplo, si el padre tiene 45 a\u00f1os y el hijo 30, este hecho pas\u00f3 hace 15 a\u00f1os, cuando el padre ten\u00eda 30 y el hijo 15. En cambio, si el padre tiene 30 a\u00f1os y el hijo tiene 7, el suceso ocurrir\u00e1 dentro de 16 a\u00f1os, cuando el padre tenga 46 y el hijo 23.</p> <p>La estrategia para resolver este reto puede ser la siguiente:</p> <ul> <li>En primer lugar, vamos restando uno a los a\u00f1os de padre e hijo hasta que, o bien la edad del padre sea el doble que la del hijo, o bien el hijo llegue a 0 a\u00f1os.</li> <li>Si no hemos conseguido encontrar la edad doble con el bucle anterior, entonces volvemos a las edades actuales y vamos sum\u00e1ndoles uno a cada edad, hasta que encontremos el doble.</li> <li>En ambos casos usaremos un contador de a\u00f1os que nos cuente cu\u00e1ntas veces decrementamos o incrementamos las edades. Ese contador ser\u00e1 la respuesta final, en uno u otro caso.</li> </ul> <p>Ejercicio 4</p> <p>Trata de resolver este reto en Python y comprueba que la plataforma lo acepta</p>"},{"location":"02e.html","title":"Algoritmos de bucles combinados","text":"<p>En este documento veremos retos donde, para resolver el problema, tendremos que hacer uso de varios bucles enlazados o anidados. Los usaremos bien para procesar los datos de entrada, bien para analizarlos del modo correcto seg\u00fan el problema. </p>"},{"location":"02e.html#1-los-saltos-de-mario","title":"1. Los saltos de Mario","text":"<p>Comenzaremos con este reto de Acepta el Reto. En \u00e9l nos van a dar varias secuencias de saltos de Mario, y tenemos que averiguar cu\u00e1ntos saltos ha dado hacia arriba (es decir, a una plataforma a una altura mayor de la que est\u00e1 ahora) y hacia abajo (a plataformas por debajo de su nivel).</p> <p>Al principio leeremos el total de casos de prueba que tenemos que examinar. Esto nos proporcionar\u00e1 el primer bucle (para recorrer todos los casos de prueba). Cada caso de prueba est\u00e1 formado por dos cosas:</p> <ul> <li>El n\u00famero de muros entre los que hay que saltar</li> <li>Las alturas de cada uno de esos muros. Aqu\u00ed vendr\u00e1 el segundo bucle (dentro del anterior), para leer cada altura de cada uno de los muros.</li> </ul> <p>Iremos procesando cada altura de cada muro y compar\u00e1ndola con la del muro anterior (menos la primera, que es desde donde empieza Mario). Si es mayor que la anterior contaremos un salto ascendente, y si es menor contaremos un salto descendente. </p> <p>Como resultado debemos mostrar el n\u00famero de saltos ascendentes y descendentes, separados por un espacio.</p> <p>Por ejemplo, imaginemos un caso de prueba en el que nos dan 8 muros con estas alturas:</p> <pre><code>1 4 2 2 3 5 3 4\n</code></pre> <ul> <li>Al pasar del muro de altura 1 al muro de altura 4, se tiene un salto ascendente. </li> <li>Al pasar de \u00e9ste al muro de altura 2 tenemos un salto descendente</li> <li>Pasamos a otro muro de altura 2: ni ascendente ni descendente</li> <li>Saltamos a un muro de altura 3. Otro salto ascendente (2)</li> <li>Pasamos a un muro de altura 5. Otro salto ascendente (3)</li> <li>Bajamos a un muro de altura 3. Contamos salto descendente (2)</li> <li>Finalmente, pasamos a un muro de altura 4, y nuevo salto ascendente (4)</li> </ul> <p>Tenemos en total 4 saltos ascendentes y 2 descendentes. Mostraremos como resultado:</p> <pre><code>4 2\n</code></pre> <p>Aqu\u00ed vemos c\u00f3mo resolver el problema en Java:</p> <pre><code>import java.util.Scanner;\n\npublic class Reto158\n{    \n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int casos = sc.nextInt();\n        int muros, arriba, abajo, previo, actual;\n\n        // Procesamos cada caso de prueba\n        for(int i = 1; i &lt;= casos; i++)\n        {\n            // Leemos la cantidad de muros\n            muros = sc.nextInt();\n            // A\u00fan no hemos hecho ning\u00fan salto desde un muro previo\n            // en esta tanda\n            previo = -1;\n            // Contadores de saltos ascendentes y descendentes\n            arriba = abajo = 0;\n            // Segundo bucle: leemos los muros de este caso\n            for(int j = 0; j &lt; muros; j++)\n            {\n                actual = sc.nextInt();\n                // Miramos si venimos de una torre previa\n                // y si es un salto arriba o abajo\n                if (previo &gt;= 0 &amp;&amp; actual &gt; previo)\n                    arriba++;\n                else if (previo &gt;= 0 &amp;&amp; actual &lt; previo)\n                    abajo++;\n                previo = actual;\n            }\n\n            System.out.println(arriba + \" \" + abajo);\n        }  \n    }\n}\n</code></pre>"},{"location":"02e.html#2-a-dibujar-hexagonos","title":"2. A dibujar hex\u00e1gonos","text":"<p>En este reto de Acepta el Reto debemos dibujar hex\u00e1gonos regulares (pol\u00edgonos de 6 lados de igual tama\u00f1o) rellenos con el s\u00edmbolo que se indique. </p> <p>Para cada caso de prueba leeremos la longitud del lado y el car\u00e1cter de relleno. Finalizaremos el proceso cuando leamos longitud 0 y car\u00e1cter de relleno 0.</p> <p>Plantearemos entonces c\u00f3mo dibujar un hex\u00e1gono. Observemos este hex\u00e1gono de lado 4, relleno de s\u00edmbolos de asterisco:</p> <pre><code>   ****\n  ******\n ********\n**********\n ********\n  ******\n   ****\n</code></pre> <p>Tendremos que dibujar el hex\u00e1gono por l\u00edneas, y el truco est\u00e1 en ver c\u00f3mo aumentan o disminuyen los s\u00edmbolos y los espacios en blanco iniciales en cada l\u00ednea. Para un hex\u00e1gono de lado 4:</p> <ul> <li>La primera l\u00ednea tiene 3 espacios y 4 s\u00edmbolos (es decir, un espacio menos que s\u00edmbolos)</li> <li>La segunda l\u00ednea tiene un espacio menos (dos) y 2 s\u00edmbolos m\u00e1s (seis)</li> <li>La tercera l\u00ednea tambi\u00e9n tiene un espacio menos (uno) y 2 s\u00edmbolos m\u00e1s (ocho)</li> <li>La cuarta l\u00ednea (con la que terminamos el lado diagonal), tambi\u00e9n tiene un espacio menos (cero) y dos s\u00edmbolos m\u00e1s (10).</li> </ul> <p>Una vez hemos alcanzado tantas repeticiones como el lado del hex\u00e1gono, comienza el dibujado de la mitad inferior, en el que vamos al rev\u00e9s: cada l\u00ednea que bajemos tendr\u00e1 un espacio m\u00e1s y dos s\u00edmbolos menos que la anterior, hasta terminar en una l\u00ednea con tantos s\u00edmbolos como el lado del hex\u00e1gono.</p> <p>Formaremos un bucle <code>for</code> formado por dos secciones: una para dibujar la mitad superior con las primeras N iteraciones (siendo N el lado del hex\u00e1gono), y otro para dibujar la mitad inferior con las N-1 \u00faltimas iteraciones (ya que el segmento central es compartido por las dos mitades y ya lo hemos dibujado).</p> <p>Dentro de cada bucle iremos incrementando o decrementando los contadores de espacios y s\u00edmbolos seg\u00fan el patr\u00f3n que hemos indicado anteriormente. Al finalizar cada uno de estos bucles haremos un salto de l\u00ednea para pasar a la siguiente iteraci\u00f3n.</p> <p>As\u00ed podr\u00eda quedar el c\u00f3digo en Java:</p> <pre><code>import java.util.Scanner;\n\npublic class RetoHexagonos\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n\n        int lado, filas, espacios, simbolos;\n        char simbolo;\n\n        // Repetimos el dibujado hasta que nos den un lado igual a 0\n        do\n        {        \n            lado = sc.nextInt();\n            // El s\u00edmbolo queda junto al lado, separado por un espacio\n            // Leemos lo que queda de l\u00ednea, limpiamos espacios con \"trim\" y\n            // nos quedamos con el \u00fanico s\u00edmbolo que queda (charAt(0))\n            simbolo = sc.nextLine().trim().charAt(0);\n\n            if(lado != 0)\n            {\n                // Tendremos tantas filas que dibujar como 2 veces el tama\u00f1o\n                // del lado (menos uno, porque el v\u00e9rtice es compartido por\n                // dos lados)\n                filas = 2 * lado - 1;\n                // El n\u00famero de espacios para la primera fila es igual al \n                // tama\u00f1o del lado menos uno\n                espacios = lado - 1;\n                // El n\u00famero de s\u00edmbolos de la primera fila es el tama\u00f1o del\n                // lado\n                simbolos = lado;\n\n                for(int i = 1; i &lt;= filas; i++)\n                {\n                    // Dibujamos los espacios que tocan en esa fila\n                    for(int j = 1; j &lt;= espacios; j++)\n                    {\n                        System.out.print(\" \");\n                    }\n                    // Luego dibujamos los s\u00edmbolos que tocan\n                    for(int j = 1; j &lt;= simbolos; j++)\n                    {\n                        System.out.print(simbolo);\n                    }\n                    System.out.println();\n                    // En la primera mitad del dibujo, los espacios bajan\n                    // de uno en uno y los s\u00edmbolos suben de dos en dos\n                    if(i &lt; lado)\n                    {\n                        espacios--;\n                        simbolos += 2;\n                    }\n                    // En la segunda mitad del dibujo es al rev\u00e9s: \n                    // los espacios suben de uno en uno y los s\u00edmbolos bajan\n                    // de dos en dos\n                    else\n                    {\n                        espacios++;\n                        simbolos -= 2;\n                    }\n                }\n            }\n        }\n        while(lado != 0);\n    }\n}\n</code></pre> <p>Observa c\u00f3mo la lectura del lado y el s\u00edmbolo se complica un poco en Java: al estar los dos datos en la misma l\u00ednea, primero leemos el lado con <code>sc.nextInt()</code>, luego leemos lo que queda de l\u00ednea con <code>sc.nextLine()</code> y tenemos que quitar los espacios que haya con <code>trim()</code> y quedarnos con el primer (y \u00fanico) s\u00edmbolo que queda, usando <code>charAt(0)</code>.</p>"},{"location":"02e.html#3-mas-retos-para-practicar","title":"3. M\u00e1s retos para practicar","text":"<p>Agrupamos en este apartado otros retos de caracter\u00edsticas similares para practicar.</p>"},{"location":"02e.html#31-galibo","title":"3.1. G\u00e1libo","text":"<p>En este reto de Acepta el Reto debemos calcular la altura m\u00e1xima que puede tener un cami\u00f3n para pasar por una serie de puentes.</p> <p>Cada caso de prueba que nos dan est\u00e1 compuesto por estos datos:</p> <ul> <li>Primero nos dir\u00e1n cu\u00e1ntos puentes tiene que atravesar el cami\u00f3n</li> <li>Para cada puente leeremos en una l\u00ednea separada sus datos: cu\u00e1ntos carriles hay en la autov\u00eda, y la altura que tiene cada carril al pasar bajo el puente</li> <li>El problema termina cuando leamos 0 puentes como primer dato del caso de prueba</li> </ul> <p>Como resultado tendremos que mostrar la altura m\u00e1xima que puede tener el cami\u00f3n para poder pasar por debajo de cada puente (eligiendo el carril apropiado).</p> <p>Veamos algunas pistas para resolver este problema:</p> <ul> <li>Una vez leamos el n\u00famero de puentes, construiremos un bucle para procesar cada puente</li> <li>Dentro de este bucle, tendremos que leer el n\u00famero de carriles, y con ello construiremos un segundo bucle (anidado) para leer la altura de cada carril</li> <li>De cada puente nos interesa quedarnos con el carril que tenga m\u00e1s altura (por ah\u00ed pasar\u00e1 el cami\u00f3n)</li> <li>Por otra parte, de todos los puentes que examinemos nos tendremos que quedar con la altura seleccionada que sea menor (ya que \u00e9sa ser\u00e1 la que condicione si el cami\u00f3n puede pasar por todos los puentes o no)</li> </ul> <p>Veamos el siguiente caso de prueba:</p> <pre><code>2\n3 300 300 250\n2 325 200\n</code></pre> <p>Nos dicen que hay dos puentes:</p> <ul> <li>El primero de ellos tiene 3 carriles con alturas 300, 300 y 250. Elegiremos cualquiera de los carriles de 300 (altura m\u00e1xima para poder pasar)</li> <li>El segundo puente tiene 2 carriles de alturas 325 y 200. Elegiremos el carril de 325 para poder pasar</li> <li>De las alturas de los dos puentes, la m\u00e1s peque\u00f1a por la que pasaremos es la de 300, por lo que nuestra altura m\u00e1xima de cami\u00f3n tendr\u00e1 que ser de 300</li> <li>AYUDA: Cada vez que termines de procesar un puente y escoger su altura m\u00e1xima, comp\u00e1rala con la altura m\u00e1xima que lleves hasta ahora y, si es menor, qu\u00e9date con la menor.</li> </ul> <p>Ejercicio 1</p> <p>Trata de resolver este reto en Java y comprueba que la plataforma lo acepta</p>"},{"location":"02e.html#32-distribucion","title":"3.2. Distribuci\u00f3n","text":"<p>En este reto de Kattis tenemos que distribuir a los equipos de una competici\u00f3n de programaci\u00f3n en salas. Nos dar\u00e1n como entrada el n\u00famero N de salas y el n\u00famero M de equipos. Hay que tener en cuenta que todas las salas son de un tama\u00f1o similar, y el objetivo es distribuir los equipos de forma equitativa entre las salas.</p> <p>La salida tendr\u00e1 que contener N l\u00edneas (una por cada sala). En cada l\u00ednea dibujaremos un asterisco <code>*</code> por cada equipo que est\u00e9 ubicado en esa sala.</p> <p>Veamos algunos ejemplos que indica el enunciado:</p> <ul> <li>Si nos dan N = 1 salas y M = 5 equipos, evidentemente debemos colocar los 5 equipos en la \u00fanica sala disponible. La salida del problema ser\u00e1 la siguiente:</li> </ul> <pre><code>*****\n</code></pre> <ul> <li>Si nos dan N = 3 salas y M = 8 equipos, hay que distribuir los equipos de forma equitativa. El propio reto dice que se admiten distintas soluciones equivalentes. En este caso, al haber 3 salas cada sala tendr\u00e1 2 equipos, y dos de ellas a\u00f1adir\u00e1n un equipo m\u00e1s para completar los 8 que hay. Aqu\u00ed vemos algunas posibles soluciones (en columnas independientes, bastar\u00eda con mostrar una de ellas):</li> </ul> <pre><code>**       ***      ***\n***      **       ***\n***      ***      **\n</code></pre> <p>Explicamos algunas pistas para resolver el reto:</p> <ul> <li>Como podr\u00e1s deducir el n\u00famero de equipos que va a cada sala es el cociente (entero) entre el n\u00famero de equipos y el n\u00famero de salas. En el ejemplo anterior 8 equipos repartidos entre 3 salas = 2 equipos por sala.</li> <li>El resto de equipos que no han cabido en la divisi\u00f3n entera (2 equipos en el ejemplo anterior), se van a\u00f1adiendo uno por sala, hasta que ya no queden.</li> </ul> <p>Ejercicio 2</p> <p>Trata de resolver este reto en C# o Python y comprueba que la plataforma lo acepta</p>"},{"location":"02e.html#33-la-media-prometida","title":"3.3. La media prometida","text":"<p>En este reto de Acepta el Reto debemos ayudar a una alumna a saber qu\u00e9 nota sacar en su \u00faltimo examen para obtener la nota media (exacta) que quiere sacar.</p> <p>Para cada caso de prueba, primero nos dir\u00e1n cu\u00e1ntos ex\u00e1menes ha hecho la alumna, y luego leeremos en la segunda l\u00ednea las notas que ha sacado en esos ex\u00e1menes. Finalmente, en la tercera l\u00ednea leeremos la media que quiere sacar. A partir de aqu\u00ed tendremos que averiguar qu\u00e9 tiene que sacar en su \u00faltimo examen para conseguir esa media y, si no es posible, mostraremos por pantalla \"IMPOSIBLE\".</p> <p>Veamos algunos ejemplos:</p> <ul> <li>La alumna ha hecho 3 ex\u00e1menes, en los que ha sacado 6, 6 y 6. Y ella quiere sacar de media un 6. Evidentemente, en su \u00faltimo examen tendr\u00e1 que volver a sacar un 6 para obtener esa media.</li> <li>Si ha hecho 2 ex\u00e1menes con notas de 10 y 10, y ella quiere sacar un 7, tendr\u00e1 que sacar un 1 en su \u00faltimo examen para que la media de notas (10 + 10 + 1) / 3 d\u00e9 7.</li> <li>Si ha hecho 3 ex\u00e1menes con notas de 6, 6 y 7 y quiere sacar de media un 8, le diremos que es IMPOSIBLE, porque para sacar una media de 8 con 4 ex\u00e1menes la suma de los 4 tendr\u00eda que dar 32 (para que, al dividir entre 4 salga 8). Pero 6 + 6 + 7 = 19. Tendr\u00eda que sacar un 13 en el \u00faltimo examen para llegar a 32, y eso es imposible.</li> </ul> <p>Ejercicio 3</p> <p>Trata de resolver este reto en Java y comprueba que la plataforma lo acepta</p>"},{"location":"02f.html","title":"Algoritmos con tipos simples","text":"<p>En este documento vamos a ver algoritmos donde, para resolver el problema a plantear, ser\u00e1 necesario utilizar un tipo de dato simple en concreto (por ejemplo, n\u00fameros reales), o mostrar la salida con un formato determinado. Incluiremos aqu\u00ed tambi\u00e9n problemas donde se tengan que manipular o procesar textos de una forma m\u00e1s o menos sencilla, como por ejemplo recorriendo sus letras buscando alguna en concreto.</p>"},{"location":"02f.html#1-trabajando-el-desbordamiento-los-origenes-del-ajedrez","title":"1. Trabajando el desbordamiento: los or\u00edgenes del ajedrez","text":"<p>En este reto de Acepta el Reto se nos plantea un problema de c\u00e1lculo: dado un tablero de ajedrez, si pedimos un grano de trigo por la primera casilla del tablero, dos granos por la segunda, cuatro por la tercera, ocho por la cuarta... y sucesivas potencias de dos por cada nueva casilla... \u00bfcu\u00e1ntos granos de trigo obtendremos?</p> <p>Procesaremos distintos casos de prueba formados por tres n\u00fameros:</p> <ul> <li>Cu\u00e1ntos granos de trigo ganamos en la primera casilla</li> <li>Por qu\u00e9 n\u00famero hay que multiplicar la cantidad de granos de trigo para pasar a la siguiente casilla</li> <li>Cu\u00e1ntas casillas tiene el tablero</li> <li>El reto terminar\u00e1 cuando leamos tres ceros como entrada</li> </ul> <p>Por ejemplo, para el siguiente caso de entrada:</p> <pre><code>1 1 10\n</code></pre> <p>Comenzamos con 1 grano de trigo, debemos multiplicar la cantidad por 1 en cada siguiente casilla y hay 10 casillas. As\u00ed que tendremos:</p> <ul> <li>1 grano en la primera casilla</li> <li>1 * 1 = 1 grano en la segunda casilla</li> <li>...</li> <li>1 * 1 = 1 grano en la d\u00e9cima casilla</li> <li>Total: 10 granos de trigo</li> </ul> <p>En cambio, en este otro caso:</p> <pre><code>3 2 3\n</code></pre> <p>Comenzamos con 3 granos en la primera casilla, debemos multiplicar por 2 en cada cambio de casilla y hay 3 casillas:</p> <ul> <li>Partimos de 3 granos en la primera casilla</li> <li>Segunda casilla = 3 * 2 = 6 granos</li> <li>Tercera casilla = 6 * 2 = 12 granos</li> <li>Total: 3 + 6 + 12 = 21 granos</li> </ul> <p>Hay que tener en cuenta que, seg\u00fan los requisitos de los datos de entrada que nos dan, los n\u00fameros pueden llegar a ser del orden de 10<sup>6</sup>. Por lo tanto, multiplicar y sumar magnitudes de ese calibre puede hacer que nos excedamos del rango que habitualmente tiene el tipo de datos entero est\u00e1ndar (<code>int</code>). En este problema debemos usar el tipo largo (<code>long</code>) para asegurarnos de que todas esas multiplicaciones y sumas no van a desbordar el l\u00edmite.</p> <p>As\u00ed podr\u00edamos resolver el reto en Java:</p> <ul> <li>Comenzamos con el n\u00famero de granos de trigo inicial</li> <li>Cada vez que pasemos a una nueva casilla, tomamos el n\u00famero de granos de la casilla anterior y lo multiplicamos por el incremento dado</li> <li>Debemos ir sumando todos estos granos por el camino</li> </ul> <pre><code>// Acepta el Reto 236: Los or\u00edgenes del ajedrez\n\nimport java.util.Scanner;\n\npublic class OrigenesAjedrez\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        long granosIniciales, incremento, casillas, granosCasilla, suma;\n\n        do\n        {\n            granosIniciales = sc.nextInt();\n            incremento = sc.nextInt();\n            casillas = sc.nextInt();\n\n            if (granosIniciales != 0 || incremento != 0 || casillas != 0)\n            {\n                // Contamos al inicio los granos de la primera casilla\n                suma = granosCasilla = granosIniciales;\n\n                // Recorremos el resto de casillas (desde la segunda)\n                for (int i = 2; i &lt;= casillas; i++)\n                {\n                    // Calculamos los granos que van a esa casilla seg\u00fan los\n                    // de la casilla anterior (por el incremento)\n                    granosCasilla = granosCasilla * incremento;\n                    // Acumulamos los granos de esa casilla en la suma total\n                    suma += granosCasilla;\n                }\n\n                System.out.println(suma);\n            }\n        } while (granosIniciales != 0 || incremento != 0 || casillas != 0);\n    }\n}\n</code></pre>"},{"location":"02f.html#2-practicando-el-formateo-de-numeros-reales-el-triangulo-de-mayor-area","title":"2. Practicando el formateo de n\u00fameros reales: el tri\u00e1ngulo de mayor \u00e1rea","text":"<p>En este reto de Acepta el Reto tenemos que calcular cu\u00e1l es el \u00e1rea del mayor tri\u00e1ngulo que se puede formar sabiendo cu\u00e1nto miden dos de sus lados.</p> <p>Fuente: Acepta el Reto</p> <p>Nos ir\u00e1n dando parejas de lados para calcular el \u00e1rea m\u00e1xima, hasta que nos den dos lados que valen 0.</p> <p>Para conocer cu\u00e1l es el \u00e1rea mayor que se puede formar, todo depende del \u00e1ngulo que formemos con esos dos segmentos, como puede verse en la imagen anterior. Intuitivamente puede verse que ese \u00e1rea ser\u00e1 mayor cuanto m\u00e1s perpendiculares pongamos entre s\u00ed los segmentos, aunque tambi\u00e9n se puede demostrar matem\u00e1ticamente. </p> <p>Note</p> <p>Llamaremos a y b a los dos segmentos que tenemos, y A al \u00e1ngulo que forman.</p> <p> </p> <p>El \u00e1rea la calcular\u00edamos como base \u00b7 altura / 2, siendo la base el lado a y la altura la cantidad h que no conocemos. Sin embargo, aplicando trigonometr\u00eda se tiene que el seno del \u00e1ngulo A que forman a y b se calcula dividiendo h / b. Despejando h en esa f\u00f3rmula, se tiene que h = b \u00b7 sen A.</p> <p>Con esto, el \u00e1rea del tri\u00e1ngulo la podemos calcular en cualquier caso como (a \u00b7 b \u00b7 sen A) / 2. Como a y b ya sabemos lo que valen, este \u00e1rea ser\u00e1 m\u00e1xima cuanto mayor sea el seno del \u00e1ngulo que forman A. El \u00e1ngulo que tiene el mayor valor del seno es el de 90\u00ba, cuyo seno vale 1 y, por tanto, obtendremos la mayor \u00e1rea poniendo los lados en \u00e1ngulo recto, y el \u00e1rea quedar\u00eda como a \u00b7 b (\u00b7 1) / 2.</p> <p>Aplicando este razonamiento, sean cuales sean los dos lados a y b que nos den calcularemos el \u00e1rea m\u00e1xima como <code>a * b / 2</code>. Una de las peculiaridades de este problema es que tenemos que sacar el resultado formateado con 1 decimal (ya que puede que no sea exacto). </p> <ul> <li>En el caso de Java, disponemos de una instrucci\u00f3n llamada <code>System.out.printf</code>. Entre comillas, con el s\u00edmbolo <code>%f</code> indicamos que queremos intercalar un n\u00famero real. Entre el porcentaje y la f podemos especificar cu\u00e1ntas cifras decimales queremos. Por ejemplo, de este modo sacar\u00edamos la variable <code>numero</code> con 2 decimales (ponemos al final <code>\\n</code> para pasar a la siguiente l\u00ednea):</li> </ul> <pre><code>float numero;\n...\nSystem.out.printf(\"El n\u00famero vale %.2f\\n\", numero);\n</code></pre> <ul> <li>En el caso de C# (aunque Acepta el Reto no admite este lenguaje) podemos usar la instrucci\u00f3n <code>ToString</code> de la variable a mostrar, indicando entre comillas el n\u00famero de decimales, tras la letra N. As\u00ed quedar\u00eda el ejemplo anterior:</li> </ul> <pre><code>float numero;\n...\nSystem.Console.WriteLine(\"El n\u00famero vale\" + numero.ToString(\"N2\"));\n</code></pre> <ul> <li>Finalmente, en Python (aunque Acepta el Reto tampoco lo acepta como lenguaje a utilizar), tenemos una sintaxis similar a la instrucci\u00f3n printf anterior, pero usando la instrucci\u00f3n <code>print</code> de Python:</li> </ul> <pre><code>print(f'El n\u00famero vale {numero:.2f}')\n</code></pre> <p>Con todo lo anterior, el reto del tri\u00e1ngulo de mayor \u00e1rea se resolver\u00eda as\u00ed en Java:</p> <pre><code>import java.util.Scanner;\n\npublic class Reto350\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        float a, b, area;\n\n        do\n        {\n            a = sc.nextFloat();\n            b = sc.nextFloat();\n            if(a != 0 || b != 0)\n            {\n                area = a * b / 2;\n                System.out.printf(\"%.1f\\n\", area);\n            }\n        }\n        while(a != 0 || b != 0);\n    }\n}\n</code></pre>"},{"location":"02f.html#21-metronomo","title":"2.1. Metr\u00f3nomo","text":"<p>En este reto de Kattis nos piden que calculemos el n\u00famero de revoluciones de un metr\u00f3nomo. Los metr\u00f3nomos se utilizan en m\u00fasica para mantener el ritmo de una canci\u00f3n o pieza musical. En el enunciado se explica que, para cada vuelta o revoluci\u00f3n completa del metr\u00f3nomo, se producen 4 ticks. Con esto, y dada la longitud de una canci\u00f3n en ticks del metr\u00f3nomo, \u00bfa cu\u00e1ntas revoluciones o vueltas se debe ajustar el metr\u00f3nomo para que termine justo cuando termina la canci\u00f3n? La cantidad la debemos dar ajustada a 2 cifras decimales</p> <p>Por ejemplo, si la longitud de la canci\u00f3n es de 16 ticks, a 4 ticks por vuelta tendremos que ajustarlo a 4.00 vueltas. En cambio, si la longitud es de 99 ticks, a 4 ticks por vuelta la tendremos que ajustar a 24.75 vueltas o revoluciones.</p> <p>Ejercicio 1</p> <p>Trata de resolver este reto en C# y comprueba que la plataforma lo acepta</p> <p>Warning</p> <p>En este caso, si el resultado tiene menos de 2 decimales no tendr\u00e1s que mostrarlos todos. Para ello, en la instrucci\u00f3n <code>ToString</code> te ser\u00e1 de utilidad el s\u00edmbolo de la almohadilla #, en lugar de especificar con N directamente el n\u00famero de decimales.</p>"},{"location":"02f.html#3-formateo-de-otros-datos-numericos-leyendo-el-diccionario","title":"3. Formateo de otros datos num\u00e9ricos: leyendo el diccionario","text":"<p>En este reto de Acepta el Reto nos pide que calculemos cu\u00e1nto tiempo se tarda en leer un diccionario. Para cada caso de prueba nos dan:</p> <ul> <li>En una l\u00ednea, cu\u00e1ntos segundos se necesitan para leer cada entrada del diccionario. El reto termina cuando leamos 0 como cantidad.</li> <li>En la siguiente l\u00ednea vienen varios n\u00fameros. Cada uno indica el n\u00famero de entradas que hay en cada p\u00e1gina del diccionario. Esta secuencia termina con un 0, para indicar que ya no hay m\u00e1s p\u00e1ginas en el diccionario.</li> </ul> <p>La peculiaridad de este reto es que debemos mostrar el tiempo total en el formato hhss (horas:minutos:segundos*, con dos d\u00edgitos en cada parte). </p> <ul> <li>Como primer paso, tendremos que calcular los segundos que tardaremos en total en procesar el diccionario. Para ello sumaremos el total de entradas de todas las p\u00e1ginas (n\u00fameros de la segunda l\u00ednea del caso de prueba), y multiplicaremos ese total por los segundos que tardamos en leer cada entrada (n\u00famero de la primera l\u00ednea del caso de prueba)</li> <li>Ahora tenemos que pasar esa cantidad en segundos a horas, minutos y segundos. Para ello debemos hacerlo de esta manera:</li> <li>Primero calculamos el n\u00famero de horas que son esos segundos, dividiendo los segundos entre 3600 segundos que tiene una hora</li> <li>El resto de la divisi\u00f3n anterior son los segundos restantes, que deberemos convertir en minutos dividiendo entre 60 segundos que tiene un minuto</li> <li>El resto de esta segunda divisi\u00f3n son los segundos que nos quedan al final</li> </ul> <p>Una vez tengamos los c\u00e1lculos hechos debemos mostrar la salida. En este caso, cada dato num\u00e9rico entero debemos mostrarlo con dos d\u00edgitos. Veremos c\u00f3mo se hace eso en los distintos lenguajes...</p> <ul> <li>En el caso de Java, la misma instrucci\u00f3n <code>System.out.printf</code> vista antes admite un s\u00edmbolo <code>%d</code> para indicar que queremos intercalar un n\u00famero entero. Entre el porcentaje y la d podemos indicar cu\u00e1nto espaciado o ceros queremos a\u00f1adir para completar. Por ejemplo, de este modo sacar\u00edamos la variable <code>numero</code> con 2 d\u00edgitos, rellenando con ceros (el 0 delante del 2 indica el car\u00e1cter de relleno para los espacios que queden):</li> </ul> <pre><code>int numero;\n...\nSystem.out.printf(\"El n\u00famero vale %02d\\n\", numero);\n</code></pre> <ul> <li>En el caso de C# (aunque Acepta el Reto no admite este lenguaje) podemos usar la instrucci\u00f3n <code>ToString</code> de la variable a mostrar, indicando entre comillas tantos ceros como cifras queramos mostrar. As\u00ed quedar\u00eda el ejemplo anterior:</li> </ul> <pre><code>int numero;\n...\nSystem.Console.WriteLine(\"El n\u00famero vale\" + numero.ToString(\"00\"));\n</code></pre> <ul> <li>Finalmente, en Python (aunque Acepta el Reto tampoco lo acepta como lenguaje a utilizar), tenemos una sintaxis similar a la instrucci\u00f3n printf anterior, pero usando la instrucci\u00f3n <code>print</code> de Python:</li> </ul> <pre><code>print(f'El n\u00famero vale {numero:02d}')\n</code></pre> <p>Con todo esto, la soluci\u00f3n al reto en Java podr\u00eda quedar as\u00ed:</p> <pre><code>import java.util.Scanner;\n\npublic class LeyendoDiccionario\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int segundosPalabra, numEntradas, totalEntradas, horas, minutos, segundos;\n\n        do\n        {\n            segundosPalabra = sc.nextInt();\n            if(segundosPalabra != 0)\n            {\n                // Procesamos la l\u00ednea con las entradas por p\u00e1gina\n                totalEntradas = 0;\n                do\n                {\n                    // Vamos leyendo hasta encontrar un 0\n                    // y acumulando en el total de entradas\n                    numEntradas = sc.nextInt();\n                    if(numEntradas != 0)\n                    {\n                        totalEntradas += numEntradas;\n                    }\n                }\n                while(numEntradas != 0);\n\n                // Calculamos tiempo total en segundos\n                segundos = totalEntradas * segundosPalabra;\n                // Calculamos horas\n                horas = segundos / 3600;\n                // Calculamos minutos\n                minutos = (segundos % 3600) / 60;\n                // Calculamos segundos\n                segundos = (segundos % 3600) % 60;\n\n                // Mostramos resultado\n                System.out.printf(\"%02d:%02d:%02d\\n\", horas, minutos, segundos);\n            }\n        }\n        while(segundosPalabra != 0);\n    }\n}\n</code></pre>"},{"location":"02f.html#31-senales-horarias","title":"3.1 Se\u00f1ales horarias","text":"<p>En este reto de Acepta el Reto debemos calcular cu\u00e1nto tiempo han estado sonando se\u00f1ales horarias en emisoras de radio. Estas se\u00f1ales se producen cada hora, y consisten en una serie de pitidos consecutivos. En concreto, el tiempo que dura la emisi\u00f3n de esos pitidos es de 6 segundos, seg\u00fan el enunciado, pero si eso lo multiplicamos por varias emisoras y d\u00edas de emisi\u00f3n, se puede convertir en mucho tiempo.</p> <p>Cada caso de prueba estar\u00e1 compuesto de dos n\u00fameros en una sola l\u00ednea, separados por espacios:</p> <ul> <li>El primero de ellos es el n\u00famero de d\u00edas en que se est\u00e1 contabilizando la emisi\u00f3n</li> <li>El segundo es el n\u00famero de emisoras que se tienen en cuenta durante esos d\u00edas</li> <li>El problema finaliza al recibir dos ceros como entrada</li> </ul> <p>Como salida debemos mostrar el tiempo total que han estado emitiendo se\u00f1ales horarias todas las emisoras todos esos d\u00edas. Igual que en el reto anterior, mostraremos el resultado con el formato hhss.</p> <p>Por ejemplo, si nos dan este caso de entrada:</p> <pre><code>3 9\n</code></pre> <p>Quiere decir que contabilizamos 3 d\u00edas y 9 emisoras. Cada d\u00eda tendr\u00e1 24 horas, multiplicado por 3 d\u00edas son 72, y multiplicado por 9 emisoras son 648 veces que se emite la se\u00f1al horaria en ese per\u00edodo de estudio. Como cada emisi\u00f3n son 6 segundos, se ha estado emitiendo un total de 648 \u00b7 6 = 3888 segundos. Esta cantidad es la que tenemos que pasar al formato hhss, quedando en este caso 01:04:48.</p> <p>Ejercicio 2</p> <p>Trata de resolver este reto en Java y comprueba que la plataforma lo acepta.</p>"},{"location":"02f.html#4-procesamiento-sencillo-de-textos-bandurria-hero","title":"4. Procesamiento sencillo de textos: Bandurria Hero","text":"<p>En este reto de Acepta el Reto nos proponen un videojuego llamado Bandurria Hero en el que tenemos que sumar puntos con notas correctas tocadas con la bandurria, al estilo de videojuegos como Guitar Hero.</p> <p>Como entrada primero leeremos el n\u00famero de casos de prueba. Cada entrada estar\u00e1 formada por un texto (una l\u00ednea) formada por s\u00edmbolos de O may\u00fasculas y puntos. Cada O may\u00fascula supone una nota tocada correctamente, y cada punto una nota incorrecta. Cada nota correcta supone 10 puntos, y si encadenamos varias seguidas, cada una supone 10 puntos m\u00e1s que la anterior.</p> <p>Por ejemplo, para este caso de prueba:</p> <pre><code>OO.OO..\n</code></pre> <ul> <li>La primera O dar\u00eda 10 puntos</li> <li>La segunda O, al ser consecutiva con la anterior, ser\u00edan 10+10 = 20</li> <li>Luego viene un punto (nota incorrecta)</li> <li>Luego viene otra O que vuelve a sumar 10 puntos (no es consecutiva con ning\u00fan acierto anterior)</li> <li>A continuaci\u00f3n llega otra O que suma 10+10 = 20 puntos</li> <li>Finalmente llegan dos notas incorrectas que no suman</li> <li>En total, la puntuaci\u00f3n ser\u00e1 de 10 + 20 + 10 + 20 = 60 puntos.</li> </ul> <p>Para resolver el reto, primero leeremos el n\u00famero de casos de prueba y con ello construiremos un bucle for para procesar cada caso. Internamente leeremos el caso en un string y lo recorreremos letra a letra hasta el final. Para cada letra:</p> <ul> <li>Si es una O, tendremos que distinguir si hab\u00eda una O previa (en cuyo caso sumamos 10 a la puntuaci\u00f3n del s\u00edmbolo anterior) o no (en cuyo caso sumamos 10 puntos nada m\u00e1s)</li> <li>Si es un punto, no sumamos nada.</li> </ul> <p>As\u00ed podr\u00edamos resolver el reto en Java. Observa c\u00f3mo leemos los datos de entrada: primero leemos el int con los casos de prueba y pasamos a la siguiente l\u00ednea (nextLine), para leer uno a uno los casos de prueba dentro del for:</p> <pre><code>import java.util.Scanner;\n\npublic class Reto634\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int casos, totalPuntos, puntosActuales;    \n        String linea;\n\n        // Leemos el n\u00famero de casos y el salto de l\u00ednea posterior\n        casos = sc.nextInt();\n        sc.nextLine();\n\n        for(int i = 0; i &lt; casos; i++)\n        {\n            // Leemos el caso de prueba\n            linea = sc.nextLine();\n            // Inicializamos contadores de puntos para este caso\n            totalPuntos = puntosActuales = 0;\n\n            // Leemos del inicio al fin del string\n            for(int j = 0; j &lt; linea.length(); j++)\n            {\n                // Con charAt(j) accedemos a cada car\u00e1cter\n                if(linea.charAt(j) == 'O')\n                {\n                    // Si es una O incrementamos el 10 los puntos\n                    // de la nota actual\n                    puntosActuales += 10;\n                    // Acumulamos los puntos\n                    totalPuntos += puntosActuales;\n                }\n                else\n                {\n                    // Si es un punto reseteamos la puntuaci\u00f3n acumulada a 0\n                    puntosActuales = 0;\n                }\n            }\n\n            System.out.println(totalPuntos);\n        }\n    }\n}\n</code></pre>"},{"location":"02f.html#41-el-ojo-de-sauron","title":"4.1. El ojo de Sauron","text":"<p>En este reto de Kattis debemos comprobar si un dibujo del ojo de Sauron (personaje de la saga de El Se\u00f1or de los Anillos) es correcto. Este ojo est\u00e1 formado por una zona central compuesta por una llama (representada con dos par\u00e9ntesis <code>()</code>), y a ambos lados la flanquean varias barras verticales. Por ejemplo:</p> <pre><code>|||||()|||||\n</code></pre> <p>Tenemos que determinar si el dibujo que hemos le\u00eddo es correcto (correct) o necesita arreglarse (fix). Un dibujo es correcto si tiene el mismo n\u00famero de barras verticales a ambos lados de la llama. Por ejemplo, el dibujo del ejemplo anterior ser\u00eda correcto, y este otro necesita arreglarse:</p> <pre><code>||()||||\n</code></pre> <p>Se garantiza que siempre habr\u00e1 una pareja de par\u00e9ntesis en el dibujo, as\u00ed que s\u00f3lo tenemos que preocuparnos de determinar si el n\u00famero de barras es igual a ambos lados.</p> <p>Ejercicio 3</p> <p>Trata de resolver este reto en C# y comprueba que la plataforma lo acepta</p>"},{"location":"03a.html","title":"Introducci\u00f3n a los algoritmos intermedios","text":"<p>En esta secci\u00f3n vamos a practicar con algunos algoritmos intermedios, donde ya se exigir\u00e1 cierto procesamiento de los datos con los que vamos a trabajar para adecuarlos al problema a tratar, o cierto an\u00e1lisis de la estrategia a seguir para conseguir un resultado eficiente.</p> <p>En muchas ocasiones encontraremos distintos algoritmos para resolver un mismo problema. Por ejemplo, para ordenar una colecci\u00f3n de datos alfab\u00e9ticamente podemos hacerlo de varias formas. A veces nos puede interesar no s\u00f3lo encontrar el algoritmo que resuelve el problema, sino que \u00e9ste sea apropiado. La idoneidad de un algoritmo se mide atendiendo a varios factores, tales como su tiempo de ejecuci\u00f3n (ser\u00e1n mejores los algoritmos que tarden menos en ejecutarse) o los recursos que necesitan (ser\u00e1n mejores los algoritmos que consuman menos recursos). Hablaremos de estos conceptos en esta secci\u00f3n.</p>"},{"location":"03b.html","title":"Algoritmos de manipulaci\u00f3n de arrays","text":"<p>Veremos en este apartado algunos algoritmos que tienen que ver con el procesamiento de arrays. Por ejemplo, leer los datos de la entrada y guardarlos en un array para hacer alg\u00fan tipo de b\u00fasqueda, o incluso almacenarlos en alguna tabla (array bidimensional).</p>"},{"location":"03b.html#1-recorrido-de-arrays-unidimensionales-senda-pirenaica","title":"1. Recorrido de arrays unidimensionales: senda pirenaica","text":"<p>En este reto de Acepta el Reto debemos calcular cu\u00e1nta distancia nos queda por recorrer tras completar cada tramo de una senda por los Pirineos.</p> <p>Para cada caso de prueba nos dar\u00e1n dos l\u00edneas:</p> <ul> <li>En la primera nos indicar\u00e1n cu\u00e1ntos tramos vamos a recorrer</li> <li>En la segunda nos dar\u00e1n, separadas por espacios, las distancias de cada tramo</li> <li>El reto finalizar\u00e1 cuando leamos 0 tramos en la primera l\u00ednea</li> </ul> <p>Una vez leamos la primera l\u00ednea de cada caso podremos crear un array de enteros para almacenar ese n\u00famero de tramos. Despu\u00e9s, a medida que leamos los n\u00fameros de la segunda l\u00ednea almacenaremos la distancia de cada tramo en su casilla correspondiente. Podemos aprovechar tambi\u00e9n para, a medida que almacenamos las distancias de cada tramo, irlas sumando para ver cu\u00e1l es la distancia total del recorrido de la senda.</p> <p>Ahora que ya tenemos el array relleno, vamos a irlo recorriendo de principio a fin. Antes de procesar cada tramo (casilla del array) sacamos por pantalla cu\u00e1nta distancia nos queda por recorrer (la distancia total que hemos calculado cuando hemos le\u00eddo los tramos), y al pasar al siguiente tramo descontaremos de ese total la distancia del tramo examinado.</p> <p>Por ejemplo, para este caso de prueba:</p> <pre><code>5\n1 2 1 2 1\n</code></pre> <p>Tenemos 5 tramos de 1, 2, 1, 2, y 1 km. En total suman 7 km. El procesamiento del caso y el resultado que mostraremos ser\u00e1 como sigue:</p> <ul> <li>Al principio nos quedan 7 km por recorrer</li> <li>Tras recorrer el primer tramo (1 km), nos quedan 6 km</li> <li>Tras recorrer el segundo tramo (2 km), nos quedan 4 km</li> <li>Tras recorrer el tercer tramo (1 km), nos quedan 3 km</li> <li>Tras recorrer el cuarto tramo (2 km), nos queda 1 km</li> <li>Tras recorrer el quinto y \u00faltimo tramo ya no nos quedar\u00e1n kil\u00f3metros pendientes, pero este cero final no se cuenta.</li> </ul> <p>As\u00ed, la salida para este caso deber\u00eda ser:</p> <pre><code>7 6 4 3 1\n</code></pre> <p>Indicamos, separados por espacios, las distancias restantes antes de iniciar cada tramo.</p> <p>Veamos c\u00f3mo resolver el problema en Java:</p> <pre><code>import java.util.Scanner;\n\npublic class SendaPirenaica\n{\n    public static void main(String[] args)\n    {        \n        Scanner sc = new Scanner(System.in);\n        int numEtapas, suma;\n\n        do\n        {\n            numEtapas = sc.nextInt();\n\n            if (numEtapas &gt; 0)\n            {            \n                int[] distancias = new int[numEtapas];\n                suma = 0;\n\n                // Leer distancias y sumarlas\n\n                for (int i = 0; i &lt; numEtapas; i++)\n                {\n                    distancias[i] = sc.nextInt();\n                    suma += distancias[i];\n                }\n\n                // Recorrer distancias y resolver el problema\n\n                for (int i = 0; i &lt; numEtapas; i++)\n                {\n                    System.out.print(suma);\n                    if (i &lt; numEtapas - 1)\n                        System.out.print(\" \");\n                    suma -= distancias[i];\n                }                \n\n                System.out.println();\n            }\n        } \n        while (numEtapas &gt; 0);\n    }    \n} \n</code></pre>"},{"location":"03b.html#11-plantas-contra-chicos-malos","title":"1.1. Plantas contra chicos malos","text":"<p>En este reto de Kattis nos trasladamos a una versi\u00f3n alternativa del juego Plants vs Zombies. Este es un juego en el que el protagonista debe sembrar su jard\u00edn con plantas de distintos tipos para evitar que los zombies lleguen a su casa. El jard\u00edn se divide en distintas filas, y en cada fila se pueden poner, en secuencia, un n\u00famero de plantas.</p> <p>En este caso, para resolver el problema nos dar\u00e1n un n\u00famero N que indica el n\u00famero de filas que tiene el jard\u00edn del protagonista. Despu\u00e9s leeremos N n\u00fameros, que representan el n\u00famero de plantas (lanzadoras de guisantes) que el protagonista ha plantado en cada fila. Por ejemplo, dado este caso de prueba:</p> <pre><code>5\n3 5 7 9 11\n</code></pre> <p>significa que el jard\u00edn tiene 5 filas, y en cada fila ha plantado 3, 5, 7, 9 y 11 plantas lanzadoras, respectivamente.</p> <p>Los zombies atacantes vienen en grupos u hordas, de forma que cada zombie en una horda decide atacar por una fila en concreto, y cada planta resiste el ataque de un zombie en cada horda. Tenemos que determinar cu\u00e1l es el n\u00famero m\u00ednimo de ataques que necesitan los zombies de una horda para pasar el jard\u00edn. Hay que tener en cuenta que las plantas de una fila s\u00f3lo protegen a la fila en la que est\u00e1n (no a las dem\u00e1s).</p> <p>En el ejemplo anterior, el n\u00famero m\u00ednimo de ataques que necesitan los zombies de una horda para pasar el jard\u00edn es de 4: con los tres primeros ataques destruir\u00edan las plantas de la fila 1, y el cuarto ataque por esa misma fila les permitir\u00eda acceder a la casa del protagonista.</p> <p>Ejercicio 1</p> <p>Trata de resolver este reto en C# y comprueba que la plataforma lo acepta.</p>"},{"location":"03b.html#2-recorrido-de-arrays-bidimensionales-matriz-identidad","title":"2. Recorrido de arrays bidimensionales: matriz identidad","text":"<p>En este reto de Acepta el Reto nos van a dar a procesar matrices bidimensionales de N filas y N columnas, y tenemos que determinar si es una matriz identidad o no.</p> <p>Una matriz identidad es aquella que tiene unos en su diagonal principal (la que va del extremo superior izquierdo al extremo inferior derecho) y ceros en el resto de casillas. Por ejemplo, esta es una matriz identidad de tama\u00f1o 4 x 4:</p> <pre><code>1 0 0 0 \n0 1 0 0\n0 0 1 0\n0 0 0 1\n</code></pre> <p>Como datos de entrada de cada caso a resolver nos dar\u00e1n:</p> <ul> <li>El n\u00famero de filas y columnas N de la tabla o matriz (un solo n\u00famero para filas y columnas)</li> <li>Luego vendr\u00e1n N filas de n\u00fameros, cada una con N columnas. Tendremos que irlos procesando y guardando en un array bidimensional del tama\u00f1o correspondiente.</li> <li>El reto finaliza cuando leamos que el tama\u00f1o de la matriz ser\u00e1 0.</li> </ul> <p>Una vez tengamos el array guardado debemos determinar si es una matriz identidad o no. Como en muchos problemas donde debemos comprobar algo, podemos empezar suponiendo una cosa (por ejemplo, que no es una matriz identidad) e intentar demostrar la contraria (que s\u00ed lo es). En este caso es m\u00e1s sencillo empezar suponiendo que s\u00ed es una matriz identidad, y en cuanto encontremos un n\u00famero que lo desmienta (por ejemplo, algo que no sea cero fuera de la diagonal principal, o que no sea uno en la diagonal principal), ya podemos decir que no es identidad.</p> <p>As\u00ed podr\u00edamos resolver el reto en Java:</p> <pre><code>import java.util.Scanner;\n\npublic class Reto151\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n;\n        int[][] datos;\n        boolean esIdentidad;\n\n        do\n        {\n            // Leemos el tama\u00f1o de la matriz (filas y columnas)\n            n = sc.nextInt();\n            if(n != 0)\n            {\n                // Creamos la matriz del tama\u00f1o indicado\n                datos = new int[n][n];\n                // Leemos cada fila\n                for(int i = 0; i &lt; n; i++)\n                {\n                    // Leemos cada columna de la fila\n                    for(int j = 0; j &lt; n; j++)\n                    {\n                        datos[i][j] = sc.nextInt();\n                    }\n                }\n\n                // Ya tenemos la matriz le\u00edda.\n                // Vemos si es identidad\n\n                // Suponemos al inicio que s\u00ed lo es\n                esIdentidad = true;\n\n                // Recorremos cada casilla de la matriz\n                // y vemos si no es identidad\n                for(int i = 0; i &lt; n; i++)\n                {\n                    for(int j = 0; j &lt; n; j++)\n                    {\n                        // Diagonal principal (i == j) debe tener unos\n                        if (i == j &amp;&amp; datos[i][j] != 1)\n                        {\n                            esIdentidad = false;\n                        }\n                        // Fuera de diagonal principal debe haber ceros\n                        else if (i != j &amp;&amp; datos[i][j] != 0)\n                        {\n                            esIdentidad = false;\n                        }\n                    }\n                }\n\n                if(esIdentidad)\n                {\n                    System.out.println(\"SI\");\n                }\n                else\n                {\n                    System.out.println(\"NO\");\n                }\n            }\n        }\n        while(n != 0);\n    }\n}\n</code></pre>"},{"location":"03b.html#21-matrices-triangulares","title":"2.1. Matrices triangulares","text":"<p>En este reto de Acepta el Reto debemos determinar si una matriz que nos dan de entrada es triangular.</p> <p>Una matriz es triangular si tiene a ceros todos los n\u00fameros por encima o por debajo de su diagonal principal (o ambos lados). La diagonal principal es irrelevante lo que tenga.</p> <p>Por ejemplo, esta matriz 4x4 ser\u00eda triangular:</p> <pre><code>1 2 3 4\n0 5 6 7\n0 0 8 9\n0 0 0 1\n</code></pre> <p>Esta otra tambi\u00e9n lo es:</p> <pre><code>1 0 0 0\n0 2 0 0\n0 0 3 0\n0 0 0 4\n</code></pre> <p>Esta \u00faltima, en cambio, no lo es (el 2 de la segunda fila, primera columna, lo impide):</p> <pre><code>1 2 3 4\n2 5 6 7\n0 0 8 9\n0 0 0 1\n</code></pre> <p>El funcionamiento es similar al del ejercicio anterior: leeremos primero un n\u00famero que nos dar\u00e1 el tama\u00f1o de la matriz (filas y columnas) y luego iremos procesando por filas los datos de la matriz. Finalmente deberemos mostrar por pantalla SI o NO, dependiendo de si la matriz es triangular o no.</p> <p>Algunas pistas:</p> <ul> <li>Las casillas por debajo de la diagonal principal tienen como caracter\u00edstica que su n\u00famero de fila (i) es mayor que su n\u00famero de columna (j)</li> <li>Las casillas por encima de la diagonal principal cumplen justo lo contrario: su n\u00famero de columna (j) es mayor que su n\u00famero de fila (i)</li> <li>Una matriz es triangular si tiene a ceros todos los datos por debajo de la diagonal principal y/o por encima de la diagonal principal.</li> </ul> <p>Ejercicio 2</p> <p>Trata de resolver este reto en Java y comprueba que la plataforma lo acepta</p>"},{"location":"03b.html#3-ordenacion-de-arrays-en-la-mente-del-timonel","title":"3. Ordenaci\u00f3n de arrays: en la mente del timonel","text":"<p>En este reto de Acepta el Reto debemos calcular cu\u00e1l es el mayor n\u00famero que podemos obtener multiplicando dos n\u00fameros de un array.</p> <p>Cada caso de prueba estar\u00e1 formado por dos l\u00edneas:</p> <ul> <li>En la primera nos dir\u00e1n cu\u00e1ntos n\u00fameros tiene el array</li> <li>En la segunda vendr\u00e1n los n\u00fameros del array, separados por espacios</li> <li>El reto finaliza cuando el primer n\u00famero sea 0.</li> </ul> <p>\u00bfC\u00f3mo calculamos el mayor producto posible con los n\u00fameros de un array? Veamos este caso de prueba:</p> <pre><code>4\n10 40 20 20\n</code></pre> <p>En este caso el mayor producto lo obtenemos multiplicando 40 x 20 = 800. B\u00e1sicamente podemos ver que tomando los dos n\u00fameros m\u00e1s grandes del array obtenemos el producto m\u00e1ximo, pero... \u00bfes siempre as\u00ed? Veamos este otro ejemplo:</p> <pre><code>4\n-10 -40 -20 -20\n</code></pre> <p>En este caso los dos n\u00fameros mayores son -10 y -20, cuyo producto es 200. En cambio, si tomamos -40 y -20 el producto es 800. No se cumple la regla anterior. \u00bfQu\u00e9 podemos hacer?</p> <p>Si observamos bien, podemos deducir que todo depende de si obtenemos el m\u00e1ximo producto multiplicando dos n\u00fameros negativos (en cuyo caso nos interesan los dos n\u00fameros menores) o positivos (en cuyo caso nos interesan los dos n\u00fameros mayores). As\u00ed que lo que haremos para resolver cada caso es:</p> <ul> <li>Ordenar el array de menor a mayor. Podemos usar la instrucci\u00f3n <code>Arrays.sort</code> en el caso de Java para hacerlo autom\u00e1ticamente</li> <li>Tomamos los dos primeros n\u00fameros (los dos menores) y los multiplicamos</li> <li>Tomamos los dos \u00faltimos n\u00fameros (los dos mayores) y los multiplicamos</li> <li>Nos quedamos con el mayor de esos dos productos</li> </ul> <p>As\u00ed podr\u00edamos resolver el reto en Java:</p> <pre><code>import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Reto458\n{\n    public static void main(String[] args) \n    {\n        Scanner sc = new Scanner(System.in);\n        int totalNumeros;\n        // Los n\u00fameros pueden ser grandes\n        long[] numeros;\n\n        do\n        {\n            totalNumeros = sc.nextInt();\n            if (totalNumeros &gt; 0)\n            {\n                // Leemos los n\u00fameros del array\n                numeros = new long[totalNumeros];\n                for (int i = 0; i &lt; totalNumeros; i++)\n                    numeros[i] = sc.nextLong();\n\n                // Ordenamos de menor a mayor\n                Arrays.sort(numeros);\n\n                // Nos quedamos con el mayor de los dos productos:\n                // Los dos primeros o los dos \u00faltimos\n                System.out.println(Math.max(\n                    numeros[0] * numeros[1], \n                    numeros[totalNumeros-2] * numeros[totalNumeros-1]));\n            }\n        } while (totalNumeros &gt; 0);        \n    }    \n}\n</code></pre>"},{"location":"03b.html#31-el-numero-que-mas-veces-se-repite","title":"3.1. El n\u00famero que m\u00e1s veces se repite","text":"<p>En este reto de CodeWars nos van a dar como entrada un array de n\u00fameros (ya relleno) y tenemos que determinar cu\u00e1l es el n\u00famero que m\u00e1s veces se repite. Por ejemplo, para este array:</p> <pre><code>[12, 10, 8, 12, 7, 6, 4, 10, 12, 10]\n</code></pre> <p>Tendremos que decir que el n\u00famero que m\u00e1s se repite es el 12. En el caso de que haya m\u00e1s de un n\u00famero que se repita el m\u00e1ximo de veces (como el 10 y el 12 en el caso anterior) elegiremos el mayor de ellos.</p> <p>Una forma de resolver el reto consiste en ordenar los n\u00fameros de menor a mayor, e ir contando cu\u00e1ntas veces aparece de forma consecutiva un n\u00famero. Cuando pasemos a un n\u00famero distinto, vemos cu\u00e1ntas veces hemos contado el anterior y, si supera (o iguala) las veces del m\u00e1ximo que llevamos hasta ahora, actualizamos a este nuevo n\u00famero.</p> <p>Notar que al ordenar de menor a mayor, si encontramos un n\u00famero que iguale las veces de uno anterior, como ser\u00e1 mayor, nos quedaremos con este nuevo n\u00famero.</p> <p>Ejercicio 3</p> <p>Trata de resolver este reto en C# y comprueba que la plataforma lo acepta</p>"},{"location":"03c.html","title":"Algoritmos de manejo avanzado de textos","text":"<p>En este apartado veremos algunos algoritmos que exigen una manipulaci\u00f3n algo avanzada de cadenas de texto. No nos limitaremos a leer un texto y recorrerlo secuencialmente o hacer comprobaciones simples, como los que hemos hecho en los retos de nivel b\u00e1sico. Procesaremos textos donde tengamos que hacer b\u00fasquedas o transformaciones m\u00e1s complejas.</p>"},{"location":"03c.html#1-busqueda-de-mensajes-cameos-de-stan-lee","title":"1. B\u00fasqueda de mensajes: cameos de Stan Lee","text":"<p>Un tipo de retos relacionados con textos que podemos resolver es el intentar buscar mensajes ocultos dentro de un texto. Comenzaremos con este reto de Acepta el Reto en el que debemos averiguar cu\u00e1ntas veces aparece el nombre de \"Stan Lee\" oculto en un texto, teniendo en cuenta que las letras del nombre pueden estar separadas, pero debemos encontrarlas en el mismo orden que el nombre.</p> <p>Por ejemplo, en el texto \"Esto es canela, verdad que si?\", el texto aparece una vez (observad las letras marcadas en negrita).</p> <p>El problema comenzar\u00e1 dici\u00e9ndonos cu\u00e1ntos textos o casos de prueba nos van a pasar, y luego leeremos cada caso de prueba (un texto en cada l\u00ednea). Para cada uno deberemos indicar cu\u00e1ntas veces hemos encontrado el nombre de \"Stan Lee\", ignorando may\u00fasculas y espacios.</p> <p>Una posible soluci\u00f3n al reto ser\u00eda esta:</p> <pre><code>import java.util.Scanner;\n\npublic class Reto475 \n{       \n    // Guardamos en una constante el texto a buscar\n    public static final String STANLEE = \"stanlee\";\n\n    public static void main(String[] args) \n    {\n        Scanner sc = new Scanner(System.in);\n        int casos, pos, cont;\n        String texto;\n\n        casos = sc.nextInt();\n        // Leemos el salto de l\u00ednea tras el n\u00famero de casos\n        sc.nextLine();\n\n        for (int i = 0; i &lt; casos; i++)\n        {\n            texto = sc.nextLine().toLowerCase();\n            cont = 0;\n            pos = 0;\n\n            for (int j = 0; j &lt; texto.length(); j++)\n            {\n                if (texto.charAt(j) == STANLEE.charAt(pos))\n                {\n                    // Hemos encontrado una letra. Pasamos a la siguiente\n                    pos++;\n                    if (pos == STANLEE.length())\n                    {\n                        // Hemos encontrado una ocurrencia completa\n                        cont++;\n                        pos = 0;\n                    }\n                }               \n            }\n\n            System.out.println(cont);\n        }       \n    }    \n}\n</code></pre> <p>Como vemos, usamos un contador <code>pos</code> para ir pasando de letra en letra por el nombre de Stan Lee, cada vez que encontramos una letra en el texto de la prueba. Cada vez que llegamos al final del nombre, incrementamos en uno el contador y volvemos a buscar desde el inicio de Stan Lee.</p>"},{"location":"03c.html#11-quinto-milenio","title":"1.1. Quinto milenio","text":"<p>En este reto de Acepta el Reto debemos hacer algo similar. En este caso debemos averiguar si un mensaje secreto est\u00e1 escrito dentro de un texto.</p> <p>Primero nos dir\u00e1n cu\u00e1ntos casos de prueba nos van a pasar, y cada caso est\u00e1 compuesto por dos l\u00edneas: una con un texto y la segunda con el mensaje secreto que tenemos que buscar. Debemos ignorar las may\u00fasculas/min\u00fasculas, y los espacios en blanco que pueda haber en el mensaje secreto (aunque s\u00ed debemos contar los signos de puntuaci\u00f3n), y decir SI o NO en funci\u00f3n de si est\u00e1 oculto o no lo est\u00e1.</p> <p>Por ejemplo, dado este texto:</p> <pre><code>...dente ...somete ... de varios periodistas ...\n</code></pre> <p>El mensaje secreto <code>Te odio.</code> SI que est\u00e1 incluido, lo podemos ver resaltado en negrita aqu\u00ed:</p> <p>...dente ...somete ... de varios periodistas ...</p> <p>Ejercicio 1</p> <p>Trata de resolver este reto en Java y comprueba que la plataforma lo acepta</p>"},{"location":"03c.html#2-recorrido-por-caracteres-multiplicando-mal","title":"2. Recorrido por caracteres: multiplicando mal","text":"<p>En este reto de Acepta el Reto debemos realizar la multiplicaci\u00f3n de dos n\u00fameros como si los estuvi\u00e9ramos sumando: tomamos las unidades, las multiplicamos entre s\u00ed y lo que nos llevamos lo pasamos a las decenas... y as\u00ed sucesivamente.</p> <p>Primero nos dir\u00e1n el n\u00famero de casos que tenemos que resolver, y cada caso viene en una sola l\u00ednea, con los dos n\u00fameros a multiplicar separados por un espacio. Lo que haremos ser\u00e1 leer la l\u00ednea, hacer un <code>split</code> para quedarnos con los dos n\u00fameros por separados y con ello iniciar el proceso. Adem\u00e1s, para nivelar los strings de los dos n\u00fameros si uno es m\u00e1s largo que otro, rellenaremos con ceros por la izquierda el n\u00famero m\u00e1s corto.</p> <p>As\u00ed, por ejemplo, si los n\u00fameros a multiplicar son 12 y 123, el resultado ser\u00eda este:</p> <pre><code>  012\nx 123\n-----\n  026\n</code></pre> <p>Como vemos, multiplicamos en columnas y, en el caso de que sobre algo lo sumamos al resultado de la columna siguiente (la de la izquierda de donde estemos).</p> <p>Aqu\u00ed vemos c\u00f3mo podr\u00edamos resolver este reto en Java:</p> <pre><code>import java.util.*;\n\npublic class MultiplicandoMal\n{\n    public static void main(String[] args) \n    {\n        Scanner sc = new Scanner(System.in);\n        int casos, indice, maxLongitud, acarreo, resultParcial;\n        String[] numeros;\n        String resultado;\n\n        casos = sc.nextInt();\n        // Leemos salto de l\u00ednea tras el n\u00famero de casos\n        sc.nextLine();\n\n        for (int i = 0; i &lt; casos; i++)\n        {\n            // Leemos los dos n\u00fameros en una l\u00ednea\n            numeros = sc.nextLine().split(\" \");\n\n            // Nos quedamos con la longitud m\u00e1s larga de los dos y \n            // rellenamos el otro n\u00famero con ceros por la izquierda\n            maxLongitud = Math.max(numeros[0].length(), numeros[1].length());\n            while(numeros[0].length() &lt; maxLongitud)\n                numeros[0] = \"0\" + numeros[0];\n            while(numeros[1].length() &lt; maxLongitud)\n                numeros[1] = \"0\" + numeros[1];\n\n            // Comenzamos multiplicando por el l\u00edmite derecho\n            indice = maxLongitud - 1;\n            acarreo = 0;\n            resultado = \"\";\n\n            while (indice &gt;= 0)\n            {\n                // Para obtener el valor num\u00e9rico de cada \"char\" le restamos\n                // el c\u00f3digo ASCII del 0\n                resultParcial = (numeros[0].charAt(indice) - '0') * \n                    (numeros[1].charAt(indice) - '0');\n                resultParcial += acarreo;\n                resultado = (resultParcial % 10) + resultado;\n                acarreo = resultParcial / 10;\n                indice--;\n            }\n\n            if (acarreo &gt; 0)\n                resultado = acarreo + resultado;\n\n            System.out.println(resultado);\n        }\n    }    \n}\n</code></pre>"},{"location":"03c.html#21-code-to-save-lives","title":"2.1. Code to Save Lives","text":"<p>En este reto de Kattis nos piden algo similar, pero para sumar n\u00fameros. Primero nos dir\u00e1n el n\u00famero de casos a resolver, y cada caso son dos l\u00edneas, con los dos n\u00fameros a sumar. En este caso, cada cifra del n\u00famero est\u00e1 separada de las otras por espacios, y debemos hacer la suma como se hace en el colegio, anotando lo que nos \"llevamos\" para la siguiente columna.</p> <p>Un ejemplo:</p> <pre><code>  3 4 5\n+ 5 6 7\n-------\n  9 1 2\n</code></pre> <p>S\u00f3lo debemos sacar el resultado final (separando tambi\u00e9n los d\u00edgitos por espacios).</p> <p>Ejercicio 2</p> <p>Trata de resolver este reto en C# y comprueba que la plataforma lo acepta.</p>"},{"location":"03c.html#3-busquedas-y-subcadenas-simon-dice","title":"3. B\u00fasquedas y subcadenas: Sim\u00f3n dice","text":"<p>En este reto de Kattis debemos jugar al juego de \"Sim\u00f3n dice\" (Simon says) y repetir todas las cosas que dice Simon. </p> <p>Como entrada nos dir\u00e1n el n\u00famero de casos de prueba, y cada caso es una frase. Si la frase comienza con el texto \"Simon says\", debemos repetir el resto de la frase. En caso contrario, debemos ignorarla. Por ejemplo, si la frase es Simon says smile., tendremos que mostrar por pantalla smile. (incluyendo el punto final). En cambio, si la frase es Lower your right hand. no debemos mostrar nada, ya que la frase no comienza con Simon says.</p> <p>Aqu\u00ed vemos c\u00f3mo podemos resolverlo en Python:</p> <pre><code># Texto por el que debe empezar la frase para repetirla\nINICIO = \"Simon says \"\n\ncasos = int(input())\n\nfor i in range(casos):\n    frase = input()\n    if frase.startswith(INICIO):\n        # Mostramos la frase quit\u00e1ndole el texto inicial \"Simon says\"\n        print(frase[len(INICIO):])\n</code></pre>"},{"location":"03c.html#31-honrar-al-pariente-apaxiano","title":"3.1. Honrar al pariente apaxiano","text":"<p>En este otro reto de Kattis debemos leer nombres de la civilizaci\u00f3n de los apaxianos y construir los nombres de los descendientes usando los nombres de sus ancestros, de la siguiente forma: en general, al nombre del descendiente a\u00f1adiremos la palabra <code>ex</code> seguida del nombre del ancestro. Por ejemplo, si el descendiente es menolaxios y el ancestro es mox, entonces el nombre del descendiente ser\u00e1 menolaxiosexmox.</p> <p>Sobre esta norma existe algunas excepciones:</p> <ul> <li>Si el nombre del descendiente termina en <code>e</code>, entonces el nombre extendido se construye a\u00f1adiendo una <code>x</code> m\u00e1s el nombre del ancestro (es decir, no a\u00f1adimos <code>ex</code>, sino <code>x</code>, ya que termina ya en <code>e</code>).</li> <li>Si el nombre del descendiente termina en cualquier otra vocal, la quitamos y concatenamos el resto con <code>ex</code> seguido del nombre del ancestro.</li> <li>Si el nombre del descendiente ya termina en <code>ex</code>, no le concatenamos de nuevo <code>ex</code>, sino s\u00f3lo el nombre del ancestro.</li> </ul> <p>Como entrada nos dar\u00e1n, separados por espacios, el nombre del descendiente y del ancestro, y debemos construir el nombre extendido siguiendo las reglas anteriores.</p> <p>Ejercicio 3</p> <p>Trata de resolver este reto en C# y comprueba que la plataforma lo acepta</p>"},{"location":"03d.html","title":"Mejorar la eficiencia de un algoritmo","text":"<p>Llegados a este punto, vamos a hablar de c\u00f3mo de complejo es un algoritmo, y c\u00f3mo tratar de mejorar su eficiencia.</p>"},{"location":"03d.html#1-la-complejidad-de-un-algoritmo","title":"1. La complejidad de un algoritmo","text":"<p>Para resolver un mismo problema, se pueden utilizar distintas estrategias o algoritmos. Normalmente interesa, no s\u00f3lo encontrar un algoritmo, sino que \u00e9ste sea suficientemente \"bueno\". La bondad de un algoritmo puede medirse por dos factores:</p> <ul> <li>El tiempo que se necesita para ejecutarse, que puede estimarse por el n\u00famero de instrucciones necesarias para completar el proceso, y el tipo de las mismas (no es lo mismo una asignaci\u00f3n que un c\u00e1lculo matem\u00e1tico complejo).</li> <li>Los recursos que se necesitan para implementar el algoritmo o, dicho de otro modo, la cantidad de memoria necesaria.</li> </ul> <p>Un algoritmo es eficiente si su consumo de tiempo o recursos es inferior a un umbral determinado por el programador. Para determinar qu\u00e9 algoritmo es m\u00e1s eficiente, se pueden utilizar dos estrategias:</p> <ul> <li>Estrategia emp\u00edrica: ejecutamos los algoritmos sobre datos de prueba y medimos el tiempo y recursos utilizados por cada uno. Esta estrategia puede resultar costosa si tenemos muchas soluciones para un mismo problema, ya que hay que programarlas y probarlas todas.</li> <li>Estrategia te\u00f3rica: es la m\u00e1s utilizada. Consiste en determinar matem\u00e1ticamente la cantidad de recursos que necesitar\u00e1 el algoritmo. Adem\u00e1s, con esta estrategia no se depende del ordenador ni del lenguaje de programaci\u00f3n elegido.</li> </ul> <p>Para poder medir la eficiencia necesitamos una unidad de medida. Lo normal en algoritmia es utilizar la notaci\u00f3n de la cota superior asint\u00f3tica (tambi\u00e9n llamada \u2018O grande\u2019 o \u2018Big-O\u2019), para establecer la complejidad de un algoritmo en funci\u00f3n de un tama\u00f1o de entrada n, siendo n un valor suficientemente grande.</p> <p>Por ejemplo, si tenemos una funci\u00f3n que se utiliza para localizar un elemento dentro de una lista de elementos previamente guardados, y se nos dice que es una operaci\u00f3n de tipo O(1), quiere decir que da igual cu\u00e1ntos elementos haya en la lista, la operaci\u00f3n siempre tarda lo mismo.</p> <p>Ahora supongamos que tenemos una funci\u00f3n que dibuja en una gr\u00e1fica los puntos que le pasemos en una matriz o array. Su documentaci\u00f3n nos dice que su complejidad es O(n). Esto quiere decir, para entendernos, que si pintar 1 punto implica, por ejemplo, 10ms, pintar 2 implicar\u00eda 20ms, 3 puntos ser\u00edan 30ms, etc... O sea, el tiempo necesario para ejecutar la funci\u00f3n depende linealmente del n\u00famero de elementos que le pasemos.</p> <p>Atendiendo a su complejidad, las notaciones m\u00e1s comunes para todo tipo de algoritmos y funciones son las que se muestran en esta lista:</p> <ul> <li>O(1): complejidad constante. La operaci\u00f3n no depende del tama\u00f1o de los datos. Es el caso ideal, pero a la vez probablemente el menos frecuente.</li> <li>O(n): lineal. El tiempo de ejecuci\u00f3n es directamente proporcional al tama\u00f1o de los datos.</li> <li>O(log n): logar\u00edtmica. por regla general se asocia con algoritmos que \"fragmentan\" el problema para abordarlo, como por ejemplo una b\u00fasqueda binaria.</li> <li>O(n log n): en este caso se trata de funciones similares a las anteriores, pero que rompen el problema en varios fragmentos por cada elemento, volviendo a recomponer informaci\u00f3n tras la ejecuci\u00f3n de cada fragmento. Por ejemplo, el algoritmo de ordenaci\u00f3n Quicksort.</li> <li>O(n<sup>2</sup>): cuadr\u00e1tica. Es t\u00edpico de algoritmos que necesitan realizar una iteraci\u00f3n por todos los elementos en cada uno de los elementos a procesar. Por ejemplo el algoritmo de ordenaci\u00f3n de burbuja.</li> <li>O(2<sup>n</sup>): exponencial. Se trata de funciones que duplican su complejidad con cada elemento a\u00f1adido al procesamiento. Son algoritmos muy raros pues en condiciones normales no deber\u00eda ser necesario hacer algo as\u00ed. Un ejemplo ser\u00eda, por ejemplo, el c\u00e1lculo recursivo de la serie de Fibonacci, que es muy poco eficiente.</li> <li>O(n!): explosi\u00f3n combinatoria. Un algoritmo que siga esta complejidad es un algoritmo totalmente fallido. Una explosi\u00f3n combinatoria se dispara de tal manera que cuando el conjunto crece un poco, lo normal es que se considere computacionalmente inviable. Solo se suele dar en algoritmos que tratan de resolver algo por la mera fuerza bruta.</li> </ul> <p>Ejercicio 1</p> <p>Indica qu\u00e9 complejidad te\u00f3rica crees que tienen los siguientes procesos:</p> <ul> <li>Buscar si un n\u00famero existe o no en un array de tama\u00f1o n</li> <li>Acceder a la casilla X de un array de tama\u00f1o n para obtener el valor almacenado</li> <li>Ordenar un array de tama\u00f1o n de mayor a menor para obtener su valor m\u00e1ximo</li> <li>Dibujar un cuadrado relleno de asteriscos de lado n en pantalla</li> </ul>"},{"location":"03d.html#2-mejorando-la-eficiencia-de-un-algoritmo","title":"2. Mejorando la eficiencia de un algoritmo","text":"<p>Vamos a tratar de mejorar la eficiencia de un algoritmo, y para ello nos basaremos en este reto de Acepta el Reto. En \u00e9l nos dicen que tenemos un puzzle de N piezas, con las piezas numeradas por la parte trasera, de la 1 a la N, pero nos falta una pieza.</p> <p>En cada caso de prueba que procesemos nos dir\u00e1n, en la primera l\u00ednea, cu\u00e1ntas piezas totales tiene el puzzle (el n\u00famero N). En la segunda l\u00ednea nos dar\u00e1n, separadas por espacios, los n\u00fameros de las piezas que tenemos (un total de N-1 piezas, ya que falta una). Tendremos que determinar, despu\u00e9s de leer todos los n\u00fameros de piezas, cu\u00e1l es la que falta.</p> <p>Por ejemplo, si el puzzle tiene N = 10 piezas, y los n\u00fameros de piezas que tenemos son 1, 2, 3, 5, 6, 7, 8, 9 y 10, podemos decir que falta la pieza 4.</p> <p>Note</p> <p>Los n\u00fameros de las piezas que nos dan no tienen por qu\u00e9 venir ordenados</p> <p>Vamos a resolver este reto de varias formas posibles, intentando mejorar la eficiencia en cada paso.</p>"},{"location":"03d.html#21-primer-intento","title":"2.1. Primer intento","text":"<p>Como primer intento, vamos a ordenar el array de menor a mayor, y vamos a ir procesando cada casilla. En la casilla 0 debe estar la pieza 1, en la casilla 1 debe estar la pieza 2... y as\u00ed sucesivamente. Cuando esta secuencia se rompa (por ejemplo, cuando en la casilla 3 est\u00e9 la pieza 5 en lugar de la 4), sabremos cu\u00e1l es la pieza que falta.</p> <p>Aqu\u00ed vemos una soluci\u00f3n al reto usando Java:</p> <pre><code>/*\n * Acepta el reto 168: La pieza perdida\n * https://aceptaelreto.com/problem/statement.php?id=168\n * Versi\u00f3n que ordena el array de piezas y busca la rotura en la secuencia\n */ \n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Reto168\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int totalPiezas, i;\n        int[] piezas;\n        boolean encontrado;\n\n        do\n        {\n            totalPiezas = sc.nextInt();\n\n            if(totalPiezas != 0)\n            {\n                piezas = new int[totalPiezas - 1];\n\n                // Leer piezas\n                for (i = 0; i &lt; piezas.length; i++)\n                {\n                    piezas[i] = sc.nextInt();\n                }\n\n                // Ordenar piezas\n                Arrays.sort(piezas);\n\n                // Recorrer array hasta encontrar descuadre en secuencia\n                i = 0; \n                encontrado = false;\n                while(!encontrado &amp;&amp; i &lt; piezas.length)\n                {\n                    if(piezas[i] != i+1)\n                    {\n                        encontrado = true;\n                    }\n                    else\n                    {\n                        i++;\n                    }\n                }\n\n                // Mostramos la pieza que falta en la casilla que no cuadra\n                System.out.println(i+1);\n            }            \n        }\n        while(totalPiezas != 0);\n    }\n}\n</code></pre> <p>Ejercicio 2</p> <p>Indica qu\u00e9 complejidad te\u00f3rica tiene el algoritmo empleado en la soluci\u00f3n anterior</p>"},{"location":"03d.html#22-segundo-intento","title":"2.2. Segundo intento","text":"<p>Como habr\u00e1s podido comprobar, el algoritmo en la soluci\u00f3n anterior tiene una complejidad de O(n<sup>2), o como mucho de O(n log n), dependiendo del algoritmo de ordenaci\u00f3n que utilicemos: un algoritmode burbuja o de intercambio directo es m\u00e1s lento (O(n<sup>2</sup>)), mientras que uno tipo QuickSort o MergeSort (como los que utiliza la instrucci\u00f3n <code>Arrays.sort</code>) es algo m\u00e1s r\u00e1pido (O(n log n)). En cualquier caso, es una complejidad mejorable. <p>En este segundo intento no vamos a ordenar el array. Vamos a descomponerlo en estos pasos:</p> <ul> <li>Sumaremos los valores de todas las piezas que tenemos del puzzle</li> <li>Sumaremos despu\u00e9s todos los valores de todas las piezas que deber\u00eda haber en el puzzle. Si tiene 10 piezas, haremos un bucle que sume de 1 a 10.</li> <li>La diferencia entre la segunda suma y la primera ser\u00e1 justamente el n\u00famero de pieza que falta.</li> </ul> <p>Aqu\u00ed tenemos la soluci\u00f3n a esta segunda versi\u00f3n:</p> <pre><code>/*\n * Acepta el reto 168: La pieza perdida\n * https://aceptaelreto.com/problem/statement.php?id=168\n * Versi\u00f3n que ordena el array de piezas y busca la rotura en la secuencia\n */ \n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Reto168\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int totalPiezas, sumaTotal, sumaParcial, pieza;\n\n        do\n        {\n            totalPiezas = sc.nextInt();\n\n            if(totalPiezas != 0)\n            {\n                sumaTotal = 0;\n                sumaParcial = 0;\n\n                // Sumar 1+2+3+...+totalPiezas\n                for(int i = 1; i &lt;= totalPiezas; i++)\n                {\n                    sumaTotal = sumaTotal + i;\n                }\n\n                // Leer totalPiezas-1 y sumarlas\n                for(int i = 1; i &lt;= totalPiezas - 1; i++)\n                {\n                    pieza = sc.nextInt();\n                    sumaParcial = sumaParcial + pieza;\n                }\n\n                // Calcular resta\n                System.out.println(sumaTotal - sumaParcial);\n            }            \n        }\n        while(totalPiezas != 0);\n    }\n}\n</code></pre> <p>Ejercicio 3</p> <p>Indica qu\u00e9 complejidad te\u00f3rica tiene ahora el algoritmo empleado</p>"},{"location":"03d.html#23-tercer-intento","title":"2.3. Tercer intento","text":"<p>El algoritmo anterior tiene ya una complejidad lineal O(n), ya que, para determinar la pieza faltante de un puzzle de N piezas, tengo que sumar N n\u00fameros. En realidad es una complejidad de 2n porque hacemos dos bucles casi iguales, pero a efectos de complejidad es pr\u00e1cticamente lo mismo.</p> <p>Sin embargo, esto sigue siendo mejorable si, para sumar los n\u00fameros de 1 a N, en lugar de usar un bucle for empleamos un m\u00e9todo llamado la suma de Gauss. El matem\u00e1tico alem\u00e1n Gauss ide\u00f3 un m\u00e9todo sencillo para sumar una secuencia de n\u00fameros consecutivos de 1 a N, observando que si vamos cogiendo n\u00fameros de los dos extremos, siempre obtenemos la misma cantidad.</p> <p>Por ejemplo, para sumar 1 + 2 + 3 + 4 + 5 + 6, la suma 1 + 6 es la misma que 2 + 5, y la misma que 3 + 4. Basta con tomar esa suma (1 + N) y multiplicarla por el n\u00famero de veces que se hace (N/2).</p> <p>As\u00ed, reemplazamos el segundo for anterior por una f\u00f3rmula que lo calcule de una sola vez:</p> <pre><code>/*\n * Acepta el reto 168: La pieza perdida\n * https://aceptaelreto.com/problem/statement.php?id=168\n * Versi\u00f3n que ordena el array de piezas y busca la rotura en la secuencia\n */ \n\nimport java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Reto168\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int totalPiezas, sumaTotal, sumaParcial, pieza;\n\n        do\n        {\n            totalPiezas = sc.nextInt();\n\n            if(totalPiezas != 0)\n            {\n                sumaTotal = 0;\n                sumaParcial = 0;\n\n                // Sumar 1+2+3+...+totalPiezas usando suma de Gauss\n                sumaTotal = (totalPiezas + 1) * totalPiezas / 2;\n\n                // Leer totalPiezas-1 y sumarlas\n                for(int i = 1; i &lt;= totalPiezas - 1; i++)\n                {\n                    pieza = sc.nextInt();\n                    sumaParcial = sumaParcial + pieza;\n                }\n\n                // Calcular resta\n                System.out.println(sumaTotal - sumaParcial);\n            }            \n        }\n        while(totalPiezas != 0);\n    }\n}\n</code></pre> <p>Esta \u00faltima complejidad es la mitad que la anterior, ya que s\u00f3lo empleamos un bucle for en lugar de dos.</p>"},{"location":"03d.html#3-mas-retos-para-practicar","title":"3. M\u00e1s retos para practicar","text":"<p>Practicaremos la mejora de la eficiencia con algunos retos adicionales planteados en esta secci\u00f3n.</p>"},{"location":"03d.html#31-ultimo-digito-del-factorial","title":"3.1. \u00daltimo d\u00edgito del factorial","text":"<p>En este reto de Acepta el Reto nos piden que calculemos cu\u00e1l es el \u00faltimo d\u00edgito del factorial de los n\u00fameros que nos van pasando. Primero nos dir\u00e1n cu\u00e1ntos n\u00fameros tenemos que procesar (n\u00famero de casos de prueba) y luego nos ir\u00e1n dando los distintos n\u00fameros a calcular.</p> <p>Por ejemplo, para el n\u00famero 4, su factorial es 4\u00b73\u00b72\u00b71 = 24, y diremos que termina en 4.</p> <p>Ejercicio 4</p> <p>Trata de resolver el reto en Java</p>"},{"location":"03d.html#32-tirando-bolos","title":"3.2. Tirando bolos","text":"<p>En este reto de Acepta el Reto nos piden que calculemos cu\u00e1ntos bolos quedan en pie despu\u00e9s de hacer una tirada. Para ello, se supone que, cuando impactamos en un bolo, se derriban todos los del tri\u00e1ngulo que se forma desde ese bolo hacia atr\u00e1s.</p> <p>Como datos de entrada para cada caso de prueba nos dar\u00e1n dos n\u00fameros: cu\u00e1ntas filas de bolos hay, y en qu\u00e9 fila (empezando por la m\u00e1s cercana) impacta la bola. El reto finalizar\u00e1 cuando estos dos datos sean cero. Hay que tener en cuenta que la fila 1 tendr\u00e1 un bolo, la fila 2 tendr\u00e1 2 bolos, la fila 3 tendr\u00e1 3 bolos... etc.</p> <p>Tambi\u00e9n hay que tener en cuenta que puede haber hasta 2<sup>31</sup> filas, por lo que el n\u00famero de bolos a contar puede ser muy grande.</p> <p>Por ejemplo, si tenemos 4 filas de bolos y la bola impacta en la fila 2, se derribar\u00e1 1 bolo de la fila 2 + 2 bolos de la fila 3 + 3 bolos de la fila 4 (6 bolos en total, ver imagen de ejemplo en la p\u00e1gina del reto). Si en total hab\u00eda 1 + 2 + 3 + 4 = 10 bolos, quedar\u00e1n en pie 10 - 6  = 4 bolos.</p> <p>Ejercicio 5</p> <p>Trata de resolver el reto en Java</p>"},{"location":"03e.html","title":"Algoritmos voraces","text":"<p>Veremos en esta secci\u00f3n un tipo de algoritmos en los que hay que procesar los datos de entrada para dejarlos de forma que, conforme se van consumiendo o analizando, se vaya resolviendo el problema que estamos tratando. Hablaremos, por tanto, de algoritmos voraces.</p>"},{"location":"03e.html#1-agujeros-en-la-manguera","title":"1. Agujeros en la manguera","text":"<p>En este reto de Acepta el Reto debemos reparar una manguera, comprando el m\u00ednimo n\u00famero de parches necesarios para tapar sus agujeros.</p> <p>Como datos de entrada en cada caso de prueba nos dar\u00e1n dos l\u00edneas:</p> <ul> <li>En la primera l\u00ednea leeremos cu\u00e1ntos agujeros tiene la manguera (N) y cu\u00e1nto miden los parches que vamos a comprar (L)</li> <li>En la segunda l\u00ednea aparecen N n\u00fameros, que nos dicen a qu\u00e9 distancia del inicio de la manguera est\u00e1 cada agujero (en orden creciente).</li> </ul> <p>Deberemos indicar cu\u00e1l es el n\u00famero m\u00ednimo de parches necesarios para tapar todos los agujeros, sabiendo que un parche de longitud L puede tapar agujeros que est\u00e9n separados entre s\u00ed hasta esa distancia (inclusive).</p>"},{"location":"03e.html#11-planteando-el-problema","title":"1.1. Planteando el problema","text":"<p>Dado que las distancias de los agujeros nos las dan en orden, lo que tenemos que hacer es irlas procesando. Cuando leamos una distancia, la guardamos y vamos leyendo las siguientes hasta que no excedan de una distancia L de la primera. Todas las que est\u00e9n comprendidas en una distancia L caben en ese primer parche. Cuando la distancia exceda de L tomamos un segundo parche, y repetimos el proceso.</p> <p>Por ejemplo, si nos dicen que la manguera tiene N = 8 agujeros, y los parches son de una longitud L = 10, y nos dan estas distancias de agujeros:</p> <pre><code>3 8 8 9 20 45 55 90\n</code></pre> <ul> <li>Con el primer parche podremos tapar los agujeros desde 3 hasta 9 (inclusive)</li> <li>Con el segundo parche podremos tapar el agujero 20</li> <li>Con el tercer parche podemos tapar los agujeros 45 y 55 (est\u00e1n justo a distancia L = 10)</li> <li>Un cuarto parche ser\u00e1 necesario para tapar el agujero 90</li> <li>En total har\u00e1n falta 4 parches</li> </ul> <p>Aqu\u00ed vemos el planteamiento en Java:</p> <pre><code>import java.util.Scanner;\n\npublic class Reto282\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n, l, distancia, distanciaAnterior, parches;\n\n        while(sc.hasNext())\n        {\n            // N\u00famero de agujeros\n            n = sc.nextInt();\n            // Longitud de los parches\n            l = sc.nextInt();\n\n            parches = 0;\n            distanciaAnterior = 0;\n            for(int i = 0; i &lt; n; i++)\n            {\n                distancia = sc.nextInt();\n                // Si es el primer agujero, o se distancia m\u00e1s de L del\n                // anterior inicio de parche...\n                if(parches == 0 || distancia - distanciaAnterior &gt; l)\n                {\n                    parches++;\n                    distanciaAnterior = distancia;\n                }\n            }\n\n            System.out.println(parches);\n        }\n    }\n}\n</code></pre> <p>Note</p> <p>El reto termina cuando ya no quedan datos que leer, por lo que la condici\u00f3n de continuaci\u00f3n del bucle ser\u00e1 mientras \"haya algo que leer\" (<code>sc.hasNext()</code>).</p>"},{"location":"03e.html#2-otros-retos-para-resolver","title":"2. Otros retos para resolver","text":"<p>De una forma similar al reto anterior se pueden resolver otros similares. Basta con procesar la entrada, ordenarla de alg\u00fan modo (si es necesario) e ir analizando los datos que hay en ella para determinar la soluci\u00f3n al problema.</p>"},{"location":"03e.html#21-seleccionando-castellers","title":"2.1. Seleccionando castellers","text":"<p>En este reto de Acepta el Reto tenemos que seleccionar a un conjunto de castellers para formar una torre humana. Para ello debemos agruparlos por alturas, ya que los castellers de un mismo piso no pueden diferir en m\u00e1s de 15 cm de altura.</p> <p>Primero leeremos el n\u00famero de casos de prueba a procesar, y como datos de entrada para cada caso de prueba nos dar\u00e1n dos l\u00edneas:</p> <ul> <li>En la primera leeremos el n\u00famero N de castellers que se quiere poner en cada nivel de la torre, y cu\u00e1ntos castellers hay disponibles (T)</li> <li>En la segunda l\u00ednea nos dan las alturas de todos los castellers disponibles, en cent\u00edmetros.</li> </ul> <p>Como salida debemos mostrar cu\u00e1ntos niveles podemos hacer agrupando los castellers en grupos de N con altura similar (m\u00e1xima diferencia de 15 cm).</p> <p>Por ejemplo, si tenemos que hacer grupos de 3 castellers, y tenemos 10 disponibles con estas alturas:</p> <pre><code>170 105 130 175 180 192 195 172 195 165\n</code></pre> <p>Pasamos primero a ordenar las alturas:</p> <pre><code>105 130 165 170 172 175 180 192 195 195\n</code></pre> <p>Ahora vemos qu\u00e9 grupos de 3 se pueden hacer:</p> <ul> <li>El de 105 no encaja con ninguno (el siguiente en altura ya mide 130)</li> <li>El de 130 tampoco (el siguiente ya mide 165)</li> <li>El de 165 se puede emparejar con los dos siguientes (primer grupo)</li> <li>Pasamos al de 175, que s\u00f3lo se puede emparejar con el de 180, no cuenta.</li> <li>El de 180 se podr\u00eda emparejar con los dos siguientes (segundo grupo)</li> <li>El \u00faltimo (195) no tiene a nadie con quien emparejarse</li> <li>Por tanto, se pueden hacer 2 alturas</li> </ul> <p>Ejercicio 1</p> <p>Trata de resolver el reto en Java</p>"},{"location":"03e.html#22-la-tienda-de-la-esquina","title":"2.2. La tienda de la esquina","text":"<p>En este reto de Acepta el Reto tenemos que ayudar a dar el cambio al due\u00f1o de una tienda. Se dispone para ello de monedas de 2 euros, 1 euro, 50 cts, 20 cts, 10 cts, 5 cts, 2 cts y 1 c\u00e9ntimo.</p> <p>Como entrada primero leeremos el n\u00famero de casos a procesar. Cada caso consta de dos valores en la misma l\u00ednea:</p> <ul> <li>Coste de la compra (expresado en c\u00e9ntimos de euro)</li> <li>Dinero entregado por el cliente (tambi\u00e9n en c\u00e9ntimos de euro)</li> </ul> <p>Como salida tenemos que indicar cu\u00e1ntas monedas de cada tipo debemos dar como cambio para que el n\u00famero de monedas total sea el m\u00ednimo necesario, o imprimir la palabra \"DEBE\" si el dinero entregado por el cliente no cubre el coste de la compra, indicando los c\u00e9ntimos a deber.</p> <p>Por ejemplo, si el coste de la compra es de 60 cts y el cliente da 200 cts, le tendremos que devolver</p> <ul> <li>0 monedas de 2 euros</li> <li>1 moneda de 1 euro</li> <li>0 monedas de 50 cts</li> <li>2 monedas de 20 cts</li> <li>0 monedas de 10 cts</li> <li>0 monedas de 5 cts</li> <li>0 monedas de 2 cts</li> <li>0 monedas de 1 c\u00e9ntimo</li> </ul> <p>Todos estos datos los mostramos en una sola l\u00ednea, separados por espacios, en este orden (de moneda de mayor valor a moneda de menor valor):</p> <pre><code>0 1 0 2 0 0 0 0\n</code></pre> <p>Por el contrario, si el coste son 300 c\u00e9ntimos y el cliente paga 30, le diremos que \"DEBE 270\".</p> <p>Ejercicio 2</p> <p>Trata de resolver el reto en Java</p>"},{"location":"04a.html","title":"Introducci\u00f3n a los algoritmos avanzados","text":"<p>En esta \u00faltima secci\u00f3n veremos algunos algoritmos que requieren un conocimiento y dominio algo m\u00e1s avanzado de la programaci\u00f3n para poderlos llevar a cabo con \u00e9xito. Veremos algunas formas recursivas que nos ser\u00e1n \u00fatiles para explorar los datos de ciertos tipos de problemas, o c\u00f3mo optimizar ese recorrido en algunos casos.</p>"},{"location":"04b.html","title":"Manejo de colecciones de objetos","text":"<p>Vamos a ver a continuaci\u00f3n algunos ejemplos de retos donde es necesario (o recomendable) almacenar la informaci\u00f3n de forma m\u00e1s compleja, empleando clases y objetos ya que hay varios datos que tratar de cada individuo del problema. Tambi\u00e9n, en algunos de estos casos, ser\u00e1 necesario ordenar la colecci\u00f3n de datos siguiendo alg\u00fan criterio para resolver el problema.</p>"},{"location":"04b.html#1-ordenando-listas-de-objetos-los-ninos-buenos","title":"1. Ordenando listas de objetos: los ni\u00f1os buenos","text":"<p>En este reto de Acepta el Reto nos plantean que resolvamos c\u00f3mo va a repartir Pap\u00e1 Noel los regalos a los ni\u00f1os. De cada ni\u00f1o tenemos dos datos: c\u00f3mo de bien se ha portado (n\u00famero entre 1 y 100) y cu\u00e1nto pesan los regalos que ha pedido (n\u00famero entre 1 y 1000). Pap\u00e1 Noel quiere repartir primero los regalos a los ni\u00f1os que mejor se han portado y, si dos ni\u00f1os se han portado igual, quiere repartir primero los regalos que pesen menos.</p> <p>Cada caso de prueba vendr\u00e1 iniciado por un n\u00famero n, que indica a cu\u00e1ntos ni\u00f1os hay que repartir regalos. Luego vienen los datos de cada ni\u00f1o en una l\u00ednea; de cada uno guardaremos dos datos: c\u00f3mo de bueno ha sido y cu\u00e1nto pesan los regalos que ha pedido. Deberemos mostrar por pantalla los datos ordenados de los ni\u00f1os, en el orden en que Pap\u00e1 Noel repartir\u00e1 los regalos.</p> <p>Por ejemplo, si tenemos este caso de entrada:</p> <pre><code>3\n80 2\n100 12\n100 1\n</code></pre> <p>Tendremos que procesar en total 3 ni\u00f1os. Primero se repartir\u00e1n los regalos a los ni\u00f1os que se han portado 100 de bien y, ante esto, se elegir\u00e1 primero al que sus regalos pesan 1, y luego al que pesan 12. Se deja en tercer lugar al ni\u00f1o que se ha portado 80 de bien. As\u00ed, la salida para este caso deber\u00eda ser:</p> <pre><code>100 1\n100 12\n80 2\n</code></pre> <p>Para empezar, crearemos una clase <code>Nino</code> que almacenar\u00e1 como atributos los datos de cada ni\u00f1o: c\u00f3mo de bueno ha sido (atributo <code>bueno</code>) y cu\u00e1nto pesan sus regalos (atributo <code>peso</code>). En el constructor asignamos las dos cosas, y hacemos que la clase implemente la interfaz <code>Comparable&lt;Nino&gt;</code> para poder comparar dos ni\u00f1os entre s\u00ed. Lo que haremos ser\u00e1 comparar el atributo <code>bueno</code> de mayor a menor y, si son iguales, entonces comparamos el atributo <code>peso</code> de menor a mayor. A\u00f1adimos tambi\u00e9n un m\u00e9todo <code>toString</code> para sacar la informaci\u00f3n del ni\u00f1o con el formato que pide el problema (<code>bueno</code> y <code>peso</code> separados por un espacio). As\u00ed quedar\u00eda esta clase:</p> <pre><code>class Nino implements Comparable&lt;Nino&gt;\n{\n    private int bueno;\n    private int peso;\n\n    public Nino(int bueno, int peso)\n    {\n        this.bueno = bueno;\n        this.peso = peso;\n    }\n\n    @Override\n    public int compareTo(Nino n)\n    {\n        // Comparamos \"bueno\" de mayor a menor\n        int resultado = Integer.compare(n.bueno, this.bueno);\n        // Si coincide, comparamos \"peso\" de menor a mayor\n        if(resultado == 0)\n        {\n            resultado = Integer.compare(this.peso, n.peso);\n        }\n        return resultado;\n    }\n\n    @Override\n    public String toString()\n    {\n        return bueno + \" \" + peso;\n    }\n}\n</code></pre> <p>Ahora que ya tenemos esta clase, podemos construir un programa principal que lea cada caso de prueba, construya una lista de objetos <code>Nino</code> con los datos que vaya leyendo de cada l\u00ednea, la ordene seg\u00fan el criterio que hemos definido en la propia clase y la saque por pantalla:</p> <pre><code>public class Reto366\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        ArrayList&lt;Nino&gt; lista;\n        int n;\n\n        do\n        {\n            // Leemos el n\u00famero de ni\u00f1os\n            n = sc.nextInt();\n            if(n != 0)\n            {\n                // Almacenamos los ni\u00f1os en una lista\n                lista = new ArrayList&lt;Nino&gt;();\n                for(int i = 1; i &lt;= n; i++)\n                {\n                    lista.add(new Nino(sc.nextInt(), sc.nextInt()));\n                }\n                // Ordenamos por el criterio de la clase Nino\n                Collections.sort(lista);\n                for(Nino nino : lista)\n                {\n                    System.out.println(nino);\n                }\n                // Debemos sacar una l\u00ednea en blanco al final de cada caso\n                System.out.println();\n            }\n        }\n        while(n != 0);\n    }\n}\n</code></pre>"},{"location":"04b.html#11-desarrollos-en-las-bicicletas","title":"1.1. Desarrollos en las bicicletas","text":"<p>En este reto de Acepta el Reto debemos hacer algo parecido con los desarrollos de las bicicletas que nos plantean. Cada caso de prueba consta de tres l\u00edneas:</p> <ul> <li>En la primera l\u00ednea nos dicen cu\u00e1ntos platos p y cu\u00e1ntas coronas c tiene la bicicleta en cuesti\u00f3n</li> <li>En la segunda l\u00ednea nos dan los tama\u00f1os de los platos, separados por espacios</li> <li>En la tercera l\u00ednea nos dan los tama\u00f1os de las coronas, separados por espacios</li> </ul> <p>La idea es crear una clase <code>Desarrollo</code> que almacene una combinaci\u00f3n de tama\u00f1o de plato y corona, y en el programa principal una lista de desarrollos que comprueba todas las combinaciones de platos y coronas que se puede tener con la bicicleta, y las ordene de menor a mayor desarrollo (es decir, de menor a mayor relaci\u00f3n entre tama\u00f1o de plato y de corona).</p> <p>Por ejemplo, para este caso de prueba:</p> <pre><code>2 3\n34 48\n20 26 34\n</code></pre> <p>Tenemos 2 platos de tama\u00f1o 34 y 48, y 3 coronas de tama\u00f1o 20, 26 y 34. Con esto salen 6 posibles combinaciones:</p> <ul> <li>Plato 34, Corona 20</li> <li>Plato 34, Corona 26</li> <li>Plato 34, Corona 34</li> <li>Plato 48, Corona 20</li> <li>Plato 48, Corona 26</li> <li>Plato 48, Corona 34</li> </ul> <p>La combinaci\u00f3n que menos desarrollo tiene es la primera (34 / 34), y la que m\u00e1s tiene es la cuarta (48 / 20). Ordenadas de menor a mayor con el formato que pide el ejercicio (mostrando plato y corona separados por un gui\u00f3n, todos en una l\u00ednea separados por espacios) quedar\u00eda as\u00ed:</p> <pre><code>34-34 34-26 48-34 34-20 48-26 48-20\n</code></pre> <p>Ejercicio 1</p> <p>Trata de resolver este reto en Java y comprueba que la plataforma lo acepta.</p>"},{"location":"04b.html#2-uso-de-diccionarios-el-telegrama-mas-corto","title":"2. Uso de diccionarios: el telegrama m\u00e1s corto","text":"<p>Vamos a practicar c\u00f3mo emplear diccionarios o mapas en retos con este reto de Acepta el Reto. En \u00e9l nos dan al principio una tabla de c\u00f3mo se codifican los distintos s\u00edmbolos en c\u00f3digo Morse, empleando puntos y rayas. Debemos procesar una serie de casos de pruebas, cada uno formado por un texto, y debemos indicar cu\u00e1l es la duraci\u00f3n en puntos totales del telegrama transcrito a Morse. Para ello se deben tener en cuenta las siguientes premisas:</p> <ul> <li>Cada raya que se emita equivale a 3 puntos</li> <li>Entre cada s\u00edmbolo (punto o raya) de una misma letra hay que esperar 1 punto</li> <li>Entre cada letra o s\u00edmbolo del mensaje hay que esperar 3 puntos</li> <li>Entre cada palabra (es decir, cada espacio en blanco que nos encontremos) hay que esperar 5 puntos</li> </ul> <p>As\u00ed, por ejemplo: </p> <ul> <li>Para el mensaje \"?\", cuyo c\u00f3digo Morse es <code>..--..</code>, tendremos en total:<ul> <li>1 + 1 + 3 + 3 + 1 + 1 = 10 puntos de los puntos y rayas del mensaje</li> <li>5 puntos, uno por la separaci\u00f3n entre cada uno de los 6 s\u00edmbolos anteriores</li> <li>Total: 15 puntos</li> </ul> </li> <li>Para el mensaje \"YA NACIO\" tendremos el siguiente c\u00f3mputo</li> <li>Y = <code>-.--</code> = 10 puntos + 3 de separaci\u00f3n = 13 puntos</li> <li>A = <code>.-</code> = 4 puntos + 1 de separaci\u00f3n = 5 puntos</li> <li>(espacio en blanco) = 5 puntos</li> <li>N = <code>-.</code> = 4 puntos + 1 de separaci\u00f3n = 5 puntos</li> <li>A = <code>.-</code> = 4 puntos + 1 de separaci\u00f3n = 5 puntos</li> <li>C = <code>-.-.</code> = 8 puntos + 3 de separaci\u00f3n = 11 puntos</li> <li>I = <code>..</code> = 2 puntos + 1 de separaci\u00f3n = 3 puntos</li> <li>O = <code>---</code> = 9 puntos + 2 de separaci\u00f3n = 11 puntos</li> <li>Adem\u00e1s, contamos 3 puntos de separaci\u00f3n entre cada letra: Y-A, N-A, A-C, C-I e I-O (15 en total)</li> <li>Suma total = 73 puntos</li> </ul> <p>Comenzaremos almacenando en un diccionario o tabla hash la codificaci\u00f3n de cada s\u00edmbolo en su cadena Morse equivalente. Esto lo haremos con la siguiente funci\u00f3n:</p> <pre><code>static HashMap&lt;Character, String&gt; crearMapaMorse()\n{\n    HashMap&lt;Character, String&gt; tabla = new HashMap&lt;&gt;();\n\n    tabla.put('A', \".-\");\n    tabla.put('B', \"-...\");\n    tabla.put('C', \"-.-.\");\n    tabla.put('D', \"-..\");\n    tabla.put('E', \".\");\n    tabla.put('F', \"..-.\");\n    tabla.put('G', \"--.\");\n    tabla.put('H', \"....\");\n    tabla.put('I', \"..\");\n    tabla.put('J', \".---\");\n    tabla.put('K', \"-.-\");\n    tabla.put('L', \".-..\");\n    tabla.put('M', \"--\");\n    tabla.put('N', \"-.\");\n    tabla.put('O', \"---\");\n    tabla.put('P', \".--.\");\n    tabla.put('Q', \"--.-\");\n    tabla.put('R', \".-.\");\n    tabla.put('S', \"...\");\n    tabla.put('T', \"-\");\n    tabla.put('U', \"..-\");\n    tabla.put('V', \"...-\");\n    tabla.put('W', \".--\");\n    tabla.put('X', \"-..-\");\n    tabla.put('Y', \"-.--\");\n    tabla.put('Z', \"--..\");\n    tabla.put('!', \"-.-.--\");\n    tabla.put('?', \"..--..\");\n\n    return tabla;\n}\n</code></pre> <p>En nuestro programa principal leeremos primero el n\u00famero de casos de prueba, y luego leemos el texto de cada caso y vamos analizando s\u00edmbolo a s\u00edmbolo:</p> <pre><code>public static void main(String[] args)\n{\n    HashMap&lt;Character, String&gt; tabla = crearMapaMorse();\n    String linea;        \n    Scanner sc = new Scanner(System.in);\n\n    // Leemos los casos y el salto de l\u00ednea que hay despu\u00e9s\n    int casos = sc.nextInt();\n    sc.nextLine();\n\n    for(int n = 1; n &lt;= casos; n++)\n    {\n        // Leemos cada caso\n        linea = sc.nextLine();\n        int total = 0;\n        // Procesamos cada s\u00edmbolo del texto le\u00eddo\n        for(int i = 0; i &lt; linea.length(); i++)\n        {\n            if(linea.charAt(i) != ' ')\n            {\n                // Obtenemos la representaci\u00f3n Morse de la letra\n                String representacion = tabla.get(linea.charAt(i));\n                for(int j = 0; j &lt; representacion.length(); j++)\n                {\n                    if(representacion.charAt(j) == '.')\n                        total += 1;\n                    else\n                        total += 3;\n                }\n                // Un punto entre cada s\u00edmbolo\n                total += representacion.length() - 1;\n\n                if (i &gt; 0 &amp;&amp; linea.charAt(i-1) != ' ')\n                {\n                    // 3 puntos entre cada letra\n                    total += 3;\n                }\n            }                \n            else\n            {\n                // 5 puntos entre cada palabra\n                total += 5;\n            }\n        }            \n\n        System.out.println(total);\n    }\n}\n</code></pre>"},{"location":"04b.html#22-ninots-indultados","title":"2.2. Ninots indultados","text":"<p>En este reto de Acepta el Reto debemos determinar qu\u00e9 ninots son indultados en las fallas de Valencia. Cada caso de prueba vendr\u00e1 dado por un n\u00famero n de votaciones de ninots, y luego seguir\u00e1n n palabras (dispuestas en varias l\u00edneas, y separadas por espacios) con los nombres de los ninots votados (en may\u00fasculas si son de fallas adultas, en min\u00fasculas si son infantiles). Debemos indicar en una l\u00ednea, y separados por espacios, los nombres de los ninots infantil y adulto que han recibido m\u00e1s votos. </p> <p>Por ejemplo, para este caso de prueba:</p> <pre><code>5\ncondealtea GUANYARDINES\nantigadecampanar QUARTEXTRAMURS GUANYARDINES\n</code></pre> <p>Deberemos indicar que en el caso de las fallas infantiles hay \"empate\", y en el de las adultas se indulta a GUANYARDINES:</p> <pre><code>empate GUANYARDINES\n</code></pre> <p>Aqu\u00ed van algunas PISTAS:</p> <ul> <li>Para leer cada palabra por separado de las siguientes puede usar el m\u00e9todo <code>next()</code> de <code>Scanner</code> (<code>sc.next()</code>), ue va procesando cada token o palabra clave que encuentra.</li> <li>Puedes crear un diccionario o mapa para guardarte las ocurrencias de las fallas infantiles y otra para las adultas (o un solo diccionario para todas). Cada vez que leas una palabra, miras si est\u00e1 en el diccionario: si no est\u00e1 la a\u00f1ades con contador 1, y si est\u00e1 le incrementas el contador. Deber\u00e1s crear para ello un diccionario cuyas claves sean Strings (nombres de las fallas) y cuyos valores sean enteros (<code>Integer</code> en Java).</li> </ul>"}]}